// https://android.googlesource.com/platform/external/qemu/+/emu-master-dev/android/android-grpc/services/emulator-controller/proto/emulator_controller.proto

// Copyright (C) 2018 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Note that if you add/remove methods in this file you must update
// the metrics sql as well ./android/scripts/gen-grpc-sql.py
//
// Please group deleted methods in a block including the date (MM/DD/YY)
// it was removed. This enables us to easily keep metrics around after removal
//
// List of deleted methods
// rpc iWasDeleted (03/12/12)
// ...

// @generated by protoc-gen-es v2.2.2 with parameter "target=ts,ts_nocheck=false"
// @generated from file emulator_controller.proto (package android.emulation.control, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { EmptySchema } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_empty } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file emulator_controller.proto.
 */
export const file_emulator_controller: GenFile = /*@__PURE__*/
  fileDesc("ChllbXVsYXRvcl9jb250cm9sbGVyLnByb3RvEhlhbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sIvkBCgpWbVJ1blN0YXRlEj0KBXN0YXRlGAEgASgOMi4uYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5WbVJ1blN0YXRlLlJ1blN0YXRlIqsBCghSdW5TdGF0ZRILCgdVTktOT1dOEAASCwoHUlVOTklORxABEg4KClJFU1RPUkVfVk0QAhIKCgZQQVVTRUQQAxILCgdTQVZFX1ZNEAQSDAoIU0hVVERPV04QBRINCglURVJNSU5BVEUQBxIJCgVSRVNFVBAJEhIKDklOVEVSTkFMX0VSUk9SEAoSCwoHUkVTVEFSVBALEgkKBVNUQVJUEAwSCAoEU1RPUBANIiIKDlBhcmFtZXRlclZhbHVlEhAKBGRhdGEYASADKAJCAhABIoAFChJQaHlzaWNhbE1vZGVsVmFsdWUSSgoGdGFyZ2V0GAEgASgOMjouYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5QaHlzaWNhbE1vZGVsVmFsdWUuUGh5c2ljYWxUeXBlEkMKBnN0YXR1cxgCIAEoDjIzLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuUGh5c2ljYWxNb2RlbFZhbHVlLlN0YXRlEjgKBXZhbHVlGAMgASgLMikuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5QYXJhbWV0ZXJWYWx1ZSJVCgVTdGF0ZRIGCgJPSxAAEhcKCk5PX1NFUlZJQ0UQ/f//////////ARIVCghESVNBQkxFRBD+//////////8BEhQKB1VOS05PV04Q////////////ASLHAgoMUGh5c2ljYWxUeXBlEgwKCFBPU0lUSU9OEAASDAoIUk9UQVRJT04QARISCg5NQUdORVRJQ19GSUVMRBACEg8KC1RFTVBFUkFUVVJFEAMSDQoJUFJPWElNSVRZEAQSCQoFTElHSFQQBRIMCghQUkVTU1VSRRAGEgwKCEhVTUlESVRZEAcSDAoIVkVMT0NJVFkQCBISCg5BTUJJRU5UX01PVElPThAJEhAKDEhJTkdFX0FOR0xFMBAKEhAKDEhJTkdFX0FOR0xFMRALEhAKDEhJTkdFX0FOR0xFMhAMEg0KCVJPTExBQkxFMBANEg0KCVJPTExBQkxFMRAOEg0KCVJPTExBQkxFMhAPEgsKB1BPU1RVUkUQEBIOCgpIRUFSVF9SQVRFEBESDgoKUkdCQ19MSUdIVBASEg4KCldSSVNUX1RJTFQQEyK3BAoLU2Vuc29yVmFsdWUSQQoGdGFyZ2V0GAEgASgOMjEuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5TZW5zb3JWYWx1ZS5TZW5zb3JUeXBlEjwKBnN0YXR1cxgCIAEoDjIsLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuU2Vuc29yVmFsdWUuU3RhdGUSOAoFdmFsdWUYAyABKAsyKS5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLlBhcmFtZXRlclZhbHVlIlUKBVN0YXRlEgYKAk9LEAASFwoKTk9fU0VSVklDRRD9//////////8BEhUKCERJU0FCTEVEEP7//////////wESFAoHVU5LTk9XThD///////////8BIpUCCgpTZW5zb3JUeXBlEhAKDEFDQ0VMRVJBVElPThAAEg0KCUdZUk9TQ09QRRABEhIKDk1BR05FVElDX0ZJRUxEEAISDwoLT1JJRU5UQVRJT04QAxIPCgtURU1QRVJBVFVSRRAEEg0KCVBST1hJTUlUWRAFEgkKBUxJR0hUEAYSDAoIUFJFU1NVUkUQBxIMCghIVU1JRElUWRAIEh8KG01BR05FVElDX0ZJRUxEX1VOQ0FMSUJSQVRFRBAJEhoKFkdZUk9TQ09QRV9VTkNBTElCUkFURUQQChIOCgpIRUFSVF9SQVRFEA4SDgoKUkdCQ19MSUdIVBAPEh0KGUFDQ0VMRVJBVElPTl9VTkNBTElCUkFURUQQESKWAQoPQnJpZ2h0bmVzc1ZhbHVlEkQKBnRhcmdldBgBIAEoDjI0LmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuQnJpZ2h0bmVzc1ZhbHVlLkxpZ2h0VHlwZRINCgV2YWx1ZRgCIAEoDSIuCglMaWdodFR5cGUSBwoDTENEEAASDAoIS0VZQk9BUkQQARIKCgZCVVRUT04QAiJJCgtEaXNwbGF5TW9kZRI6CgV2YWx1ZRgBIAEoDjIrLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuRGlzcGxheU1vZGVWYWx1ZSLaAQoKTG9nTWVzc2FnZRIQCghjb250ZW50cxgBIAEoCRIRCgVzdGFydBgCIAEoA0ICGAESEAoEbmV4dBgDIAEoA0ICGAESOwoEc29ydBgEIAEoDjItLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuTG9nTWVzc2FnZS5Mb2dUeXBlEjcKB2VudHJpZXMYBSADKAsyJi5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLkxvZ2NhdEVudHJ5Ih8KB0xvZ1R5cGUSCAoEVGV4dBAAEgoKBlBhcnNlZBABIoYCCgtMb2djYXRFbnRyeRIRCgl0aW1lc3RhbXAYASABKAQSCwoDcGlkGAIgASgNEgsKA3RpZBgDIAEoDRI+CgVsZXZlbBgEIAEoDjIvLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuTG9nY2F0RW50cnkuTG9nTGV2ZWwSCwoDdGFnGAUgASgJEgsKA21zZxgGIAEoCSJwCghMb2dMZXZlbBILCgdVTktOT1dOEAASCwoHREVGQVVMVBABEgsKB1ZFUkJPU0UQAhIJCgVERUJVRxADEggKBElORk8QBBIICgRXQVJOEAUSBwoDRVJSEAYSCQoFRkFUQUwQBxIKCgZTSUxFTlQQCCLxAQoPVm1Db25maWd1cmF0aW9uElMKDmh5cGVydmlzb3JUeXBlGAEgASgOMjsuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5WbUNvbmZpZ3VyYXRpb24uVm1IeXBlcnZpc29yVHlwZRIYChBudW1iZXJPZkNwdUNvcmVzGAIgASgFEhQKDHJhbVNpemVCeXRlcxgDIAEoAyJZChBWbUh5cGVydmlzb3JUeXBlEgsKB1VOS05PV04QABIICgROT05FEAESBwoDS1ZNEAISCAoESEFYTRADEgcKA0hWRhAEEggKBFdIUFgQBRIICgRBRUhEEAYiGAoIQ2xpcERhdGESDAoEdGV4dBgBIAEoCSKPAgoFVG91Y2gSCQoBeBgBIAEoBRIJCgF5GAIgASgFEhIKCmlkZW50aWZpZXIYAyABKAUSEAoIcHJlc3N1cmUYBCABKAUSEwoLdG91Y2hfbWFqb3IYBSABKAUSEwoLdG91Y2hfbWlub3IYBiABKAUSRAoKZXhwaXJhdGlvbhgHIAEoDjIwLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuVG91Y2guRXZlbnRFeHBpcmF0aW9uEhMKC29yaWVudGF0aW9uGAggASgFIkUKD0V2ZW50RXhwaXJhdGlvbhIgChxFVkVOVF9FWFBJUkFUSU9OX1VOU1BFQ0lGSUVEEAASEAoMTkVWRVJfRVhQSVJFEAEiaQoDUGVuEjIKCGxvY2F0aW9uGAEgASgLMiAuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5Ub3VjaBIWCg5idXR0b25fcHJlc3NlZBgCIAEoCBIWCg5ydWJiZXJfcG9pbnRlchgDIAEoCCJQCgpUb3VjaEV2ZW50EjEKB3RvdWNoZXMYASADKAsyIC5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLlRvdWNoEg8KB2Rpc3BsYXkYAiABKAUiSwoIUGVuRXZlbnQSLgoGZXZlbnRzGAEgAygLMh4uYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5QZW4SDwoHZGlzcGxheRgCIAEoBSJECgpNb3VzZUV2ZW50EgkKAXgYASABKAUSCQoBeRgCIAEoBRIPCgdidXR0b25zGAMgASgFEg8KB2Rpc3BsYXkYBCABKAUiNQoKV2hlZWxFdmVudBIKCgJkeBgBIAEoBRIKCgJkeRgCIAEoBRIPCgdkaXNwbGF5GAMgASgFIsECCg1LZXlib2FyZEV2ZW50EkYKCGNvZGVUeXBlGAEgASgOMjQuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5LZXlib2FyZEV2ZW50LktleUNvZGVUeXBlEkgKCWV2ZW50VHlwZRgCIAEoDjI1LmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuS2V5Ym9hcmRFdmVudC5LZXlFdmVudFR5cGUSDwoHa2V5Q29kZRgDIAEoBRILCgNrZXkYBCABKAkSDAoEdGV4dBgFIAEoCSI8CgtLZXlDb2RlVHlwZRIHCgNVc2IQABIJCgVFdmRldhABEgcKA1hLQhACEgcKA1dpbhADEgcKA01hYxAEIjQKDEtleUV2ZW50VHlwZRILCgdrZXlkb3duEAASCQoFa2V5dXAQARIMCghrZXlwcmVzcxACIokDCgpJbnB1dEV2ZW50Ej0KCWtleV9ldmVudBgBIAEoCzIoLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuS2V5Ym9hcmRFdmVudEgAEjwKC3RvdWNoX2V2ZW50GAIgASgLMiUuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5Ub3VjaEV2ZW50SAASPAoLbW91c2VfZXZlbnQYAyABKAsyJS5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLk1vdXNlRXZlbnRIABJACg1hbmRyb2lkX2V2ZW50GAQgASgLMicuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5BbmRyb2lkRXZlbnRIABI4CglwZW5fZXZlbnQYBSABKAsyIy5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLlBlbkV2ZW50SAASPAoLd2hlZWxfZXZlbnQYBiABKAsyJS5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLldoZWVsRXZlbnRIAEIGCgR0eXBlIkoKDEFuZHJvaWRFdmVudBIMCgR0eXBlGAEgASgFEgwKBGNvZGUYAiABKAUSDQoFdmFsdWUYAyABKAUSDwoHZGlzcGxheRgEIAEoBSIyCgtGaW5nZXJwcmludBISCgppc1RvdWNoaW5nGAEgASgIEg8KB3RvdWNoSWQYAiABKAUijAEKCEdwc1N0YXRlEhUKDXBhc3NpdmVVcGRhdGUYASABKAgSEAoIbGF0aXR1ZGUYAiABKAESEQoJbG9uZ2l0dWRlGAMgASgBEg0KBXNwZWVkGAQgASgBEg8KB2JlYXJpbmcYBSABKAESEAoIYWx0aXR1ZGUYBiABKAESEgoKc2F0ZWxsaXRlcxgHIAEoBSKHBAoMQmF0dGVyeVN0YXRlEhIKCmhhc0JhdHRlcnkYASABKAgSEQoJaXNQcmVzZW50GAIgASgIEkcKB2NoYXJnZXIYAyABKA4yNi5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLkJhdHRlcnlTdGF0ZS5CYXR0ZXJ5Q2hhcmdlchITCgtjaGFyZ2VMZXZlbBgEIAEoBRJFCgZoZWFsdGgYBSABKA4yNS5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLkJhdHRlcnlTdGF0ZS5CYXR0ZXJ5SGVhbHRoEkUKBnN0YXR1cxgGIAEoDjI1LmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuQmF0dGVyeVN0YXRlLkJhdHRlcnlTdGF0dXMiVwoNQmF0dGVyeVN0YXR1cxILCgdVTktOT1dOEAASDAoIQ0hBUkdJTkcQARIPCgtESVNDSEFSR0lORxACEhAKDE5PVF9DSEFSR0lORxADEggKBEZVTEwQBCI5Cg5CYXR0ZXJ5Q2hhcmdlchIICgROT05FEAASBgoCQUMQARIHCgNVU0IQAhIMCghXSVJFTEVTUxADIlAKDUJhdHRlcnlIZWFsdGgSCAoER09PRBAAEgoKBkZBSUxFRBABEggKBERFQUQQAhIPCgtPVkVSVk9MVEFHRRADEg4KCk9WRVJIRUFURUQQBCKuAQoOSW1hZ2VUcmFuc3BvcnQSSwoHY2hhbm5lbBgBIAEoDjI6LmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuSW1hZ2VUcmFuc3BvcnQuVHJhbnNwb3J0Q2hhbm5lbBIOCgZoYW5kbGUYAiABKAkiPwoQVHJhbnNwb3J0Q2hhbm5lbBIhCh1UUkFOU1BPUlRfQ0hBTk5FTF9VTlNQRUNJRklFRBAAEggKBE1NQVAQASJQCg1Gb2xkZWREaXNwbGF5Eg0KBXdpZHRoGAEgASgNEg4KBmhlaWdodBgCIAEoDRIPCgd4T2Zmc2V0GAMgASgNEg8KB3lPZmZzZXQYBCABKA0ipwMKC0ltYWdlRm9ybWF0EkAKBmZvcm1hdBgBIAEoDjIwLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuSW1hZ2VGb3JtYXQuSW1nRm9ybWF0EjUKCHJvdGF0aW9uGAIgASgLMiMuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5Sb3RhdGlvbhINCgV3aWR0aBgDIAEoDRIOCgZoZWlnaHQYBCABKA0SDwoHZGlzcGxheRgFIAEoDRI8Cgl0cmFuc3BvcnQYBiABKAsyKS5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLkltYWdlVHJhbnNwb3J0Ej8KDWZvbGRlZERpc3BsYXkYByABKAsyKC5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLkZvbGRlZERpc3BsYXkSQAoLZGlzcGxheU1vZGUYCCABKA4yKy5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLkRpc3BsYXlNb2RlVmFsdWUiLgoJSW1nRm9ybWF0EgcKA1BORxAAEgwKCFJHQkE4ODg4EAESCgoGUkdCODg4EAIilwEKBUltYWdlEjYKBmZvcm1hdBgBIAEoCzImLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuSW1hZ2VGb3JtYXQSEQoFd2lkdGgYAiABKA1CAhgBEhIKBmhlaWdodBgDIAEoDUICGAESDQoFaW1hZ2UYBCABKAwSCwoDc2VxGAUgASgNEhMKC3RpbWVzdGFtcFVzGAYgASgEItUBCghSb3RhdGlvbhJCCghyb3RhdGlvbhgBIAEoDjIwLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuUm90YXRpb24uU2tpblJvdGF0aW9uEg0KBXhBeGlzGAIgASgBEg0KBXlBeGlzGAMgASgBEg0KBXpBeGlzGAQgASgBIlgKDFNraW5Sb3RhdGlvbhIMCghQT1JUUkFJVBAAEg0KCUxBTkRTQ0FQRRABEhQKEFJFVkVSU0VfUE9SVFJBSVQQAhIVChFSRVZFUlNFX0xBTkRTQ0FQRRADIvQBCglQaG9uZUNhbGwSQQoJb3BlcmF0aW9uGAEgASgOMi4uYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5QaG9uZUNhbGwuT3BlcmF0aW9uEg4KBm51bWJlchgCIAEoCSKTAQoJT3BlcmF0aW9uEgwKCEluaXRDYWxsEAASDgoKQWNjZXB0Q2FsbBABEhYKElJlamVjdENhbGxFeHBsaWNpdBACEhIKDlJlamVjdENhbGxCdXN5EAMSEgoORGlzY29ubmVjdENhbGwQBBITCg9QbGFjZUNhbGxPbkhvbGQQBRITCg9UYWtlQ2FsbE9mZkhvbGQQBiK8AQoNUGhvbmVSZXNwb25zZRJDCghyZXNwb25zZRgBIAEoDjIxLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuUGhvbmVSZXNwb25zZS5SZXNwb25zZSJmCghSZXNwb25zZRIGCgJPSxAAEhAKDEJhZE9wZXJhdGlvbhABEg0KCUJhZE51bWJlchACEhEKDUludmFsaWRBY3Rpb24QAxIQCgxBY3Rpb25GYWlsZWQQBBIMCghSYWRpb09mZhAFIiMKBUVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCSI8CglFbnRyeUxpc3QSLwoFZW50cnkYASADKAsyIC5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLkVudHJ5ItABCg5FbXVsYXRvclN0YXR1cxIPCgd2ZXJzaW9uGAEgASgJEg4KBnVwdGltZRgCIAEoBBIOCgZib290ZWQYAyABKAgSPAoIdm1Db25maWcYBCABKAsyKi5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLlZtQ29uZmlndXJhdGlvbhI8Cg5oYXJkd2FyZUNvbmZpZxgFIAEoCzIkLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuRW50cnlMaXN0EhEKCWhlYXJ0YmVhdBgGIAEoBCL7AgoLQXVkaW9Gb3JtYXQSFAoMc2FtcGxpbmdSYXRlGAEgASgEEkEKCGNoYW5uZWxzGAIgASgOMi8uYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5BdWRpb0Zvcm1hdC5DaGFubmVscxJDCgZmb3JtYXQYAyABKA4yMy5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLkF1ZGlvRm9ybWF0LlNhbXBsZUZvcm1hdBJBCgRtb2RlGAQgASgOMjMuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5BdWRpb0Zvcm1hdC5EZWxpdmVyeU1vZGUiLwoMU2FtcGxlRm9ybWF0Eg4KCkFVRF9GTVRfVTgQABIPCgtBVURfRk1UX1MxNhABIiAKCENoYW5uZWxzEggKBE1vbm8QABIKCgZTdGVyZW8QASI4CgxEZWxpdmVyeU1vZGUSFAoQTU9ERV9VTlNQRUNJRklFRBAAEhIKDk1PREVfUkVBTF9USU1FEAEiZwoLQXVkaW9QYWNrZXQSNgoGZm9ybWF0GAEgASgLMiYuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5BdWRpb0Zvcm1hdBIRCgl0aW1lc3RhbXAYAiABKAQSDQoFYXVkaW8YAyABKAwiLgoKU21zTWVzc2FnZRISCgpzcmNBZGRyZXNzGAEgASgJEgwKBHRleHQYAiABKAkiywIKFERpc3BsYXlDb25maWd1cmF0aW9uEg0KBXdpZHRoGAEgASgNEg4KBmhlaWdodBgCIAEoDRILCgNkcGkYAyABKA0SDQoFZmxhZ3MYBCABKA0SDwoHZGlzcGxheRgFIAEoDSLmAQoMRGlzcGxheUZsYWdzEhwKGERJU1BMQVlGTEFHU19VTlNQRUNJRklFRBAAEh8KG1ZJUlRVQUxfRElTUExBWV9GTEFHX1BVQkxJQxABEiUKIVZJUlRVQUxfRElTUExBWV9GTEFHX1BSRVNFTlRBVElPThACEh8KG1ZJUlRVQUxfRElTUExBWV9GTEFHX1NFQ1VSRRAEEikKJVZJUlRVQUxfRElTUExBWV9GTEFHX09XTl9DT05URU5UX09OTFkQCBIkCiBWSVJUVUFMX0RJU1BMQVlfRkxBR19BVVRPX01JUlJPUhAQIokBChVEaXNwbGF5Q29uZmlndXJhdGlvbnMSQQoIZGlzcGxheXMYASADKAsyLy5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLkRpc3BsYXlDb25maWd1cmF0aW9uEhgKEHVzZXJDb25maWd1cmFibGUYAiABKA0SEwoLbWF4RGlzcGxheXMYAyABKA0i2wQKDE5vdGlmaWNhdGlvbhJECgVldmVudBgBIAEoDjIxLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuTm90aWZpY2F0aW9uLkV2ZW50VHlwZUICGAESSwoSY2FtZXJhTm90aWZpY2F0aW9uGAIgASgLMi0uYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5DYW1lcmFOb3RpZmljYXRpb25IABJ3CihkaXNwbGF5Q29uZmlndXJhdGlvbnNDaGFuZ2VkTm90aWZpY2F0aW9uGAMgASgLMkMuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5EaXNwbGF5Q29uZmlndXJhdGlvbnNDaGFuZ2VkTm90aWZpY2F0aW9uSAASNQoHcG9zdHVyZRgEIAEoCzIiLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuUG9zdHVyZUgAEkYKBmJvb3RlZBgFIAEoCzI0LmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuQm9vdENvbXBsZXRlZE5vdGlmaWNhdGlvbkgAEkAKCmJyaWdodG5lc3MYBiABKAsyKi5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLkJyaWdodG5lc3NWYWx1ZUgAInYKCUV2ZW50VHlwZRIhCh1WSVJUVUFMX1NDRU5FX0NBTUVSQV9JTkFDVElWRRAAEh8KG1ZJUlRVQUxfU0NFTkVfQ0FNRVJBX0FDVElWRRABEiUKIURJU1BMQVlfQ09ORklHVVJBVElPTlNfQ0hBTkdFRF9VSRACQgYKBHR5cGUiKQoZQm9vdENvbXBsZXRlZE5vdGlmaWNhdGlvbhIMCgR0aW1lGAEgASgFIjUKEkNhbWVyYU5vdGlmaWNhdGlvbhIOCgZhY3RpdmUYASABKAgSDwoHZGlzcGxheRgCIAEoBSJ7CihEaXNwbGF5Q29uZmlndXJhdGlvbnNDaGFuZ2VkTm90aWZpY2F0aW9uEk8KFWRpc3BsYXlDb25maWd1cmF0aW9ucxgBIAEoCzIwLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuRGlzcGxheUNvbmZpZ3VyYXRpb25zIjEKDlJvdGF0aW9uUmFkaWFuEgkKAXgYASABKAISCQoBeRgCIAEoAhIJCgF6GAMgASgCIisKCFZlbG9jaXR5EgkKAXgYASABKAISCQoBeRgCIAEoAhIJCgF6GAMgASgCIugBCgdQb3N0dXJlEj4KBXZhbHVlGAMgASgOMi8uYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5Qb3N0dXJlLlBvc3R1cmVWYWx1ZSKcAQoMUG9zdHVyZVZhbHVlEhMKD1BPU1RVUkVfVU5LTk9XThAAEhIKDlBPU1RVUkVfQ0xPU0VEEAESFwoTUE9TVFVSRV9IQUxGX09QRU5FRBACEhIKDlBPU1RVUkVfT1BFTkVEEAMSEwoPUE9TVFVSRV9GTElQUEVEEAQSEAoMUE9TVFVSRV9URU5UEAUSDwoLUE9TVFVSRV9NQVgQBiIdCgtQaG9uZU51bWJlchIOCgZudW1iZXIYASABKAkqRAoQRGlzcGxheU1vZGVWYWx1ZRIJCgVQSE9ORRAAEgwKCEZPTERBQkxFEAESCgoGVEFCTEVUEAISCwoHREVTS1RPUBADMoYdChJFbXVsYXRvckNvbnRyb2xsZXISYgoMc3RyZWFtU2Vuc29yEiYuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5TZW5zb3JWYWx1ZRomLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuU2Vuc29yVmFsdWUiADABEl0KCWdldFNlbnNvchImLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuU2Vuc29yVmFsdWUaJi5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLlNlbnNvclZhbHVlIgASTQoJc2V0U2Vuc29yEiYuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5TZW5zb3JWYWx1ZRoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eSIAElsKEHNldFBoeXNpY2FsTW9kZWwSLS5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLlBoeXNpY2FsTW9kZWxWYWx1ZRoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eSIAEnIKEGdldFBoeXNpY2FsTW9kZWwSLS5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLlBoeXNpY2FsTW9kZWxWYWx1ZRotLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuUGh5c2ljYWxNb2RlbFZhbHVlIgASdwoTc3RyZWFtUGh5c2ljYWxNb2RlbBItLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuUGh5c2ljYWxNb2RlbFZhbHVlGi0uYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5QaHlzaWNhbE1vZGVsVmFsdWUiADABEk0KDHNldENsaXBib2FyZBIjLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuQ2xpcERhdGEaFi5nb29nbGUucHJvdG9idWYuRW1wdHkiABJNCgxnZXRDbGlwYm9hcmQSFi5nb29nbGUucHJvdG9idWYuRW1wdHkaIy5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLkNsaXBEYXRhIgASUgoPc3RyZWFtQ2xpcGJvYXJkEhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5GiMuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5DbGlwRGF0YSIAMAESTwoKc2V0QmF0dGVyeRInLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuQmF0dGVyeVN0YXRlGhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5IgASTwoKZ2V0QmF0dGVyeRIWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eRonLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuQmF0dGVyeVN0YXRlIgASRwoGc2V0R3BzEiMuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5HcHNTdGF0ZRoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eSIAEkcKBmdldEdwcxIWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eRojLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuR3BzU3RhdGUiABJTCg9zZW5kRmluZ2VycHJpbnQSJi5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLkZpbmdlcnByaW50GhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5IgASTQoHc2VuZEtleRIoLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuS2V5Ym9hcmRFdmVudBoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eSIAEkwKCXNlbmRUb3VjaBIlLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuVG91Y2hFdmVudBoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eSIAEkwKCXNlbmRNb3VzZRIlLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuTW91c2VFdmVudBoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eSIAElAKC2luamVjdFdoZWVsEiUuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5XaGVlbEV2ZW50GhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5IgAoARJVChBzdHJlYW1JbnB1dEV2ZW50EiUuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5JbnB1dEV2ZW50GhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5IgAoARJdCglzZW5kUGhvbmUSJC5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLlBob25lQ2FsbBooLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuUGhvbmVSZXNwb25zZSIAElwKB3NlbmRTbXMSJS5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLlNtc01lc3NhZ2UaKC5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLlBob25lUmVzcG9uc2UiABJkCg5zZXRQaG9uZU51bWJlchImLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuUGhvbmVOdW1iZXIaKC5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLlBob25lUmVzcG9uc2UiABJQCglnZXRTdGF0dXMSFi5nb29nbGUucHJvdG9idWYuRW1wdHkaKS5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLkVtdWxhdG9yU3RhdHVzIgASWwoNZ2V0U2NyZWVuc2hvdBImLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuSW1hZ2VGb3JtYXQaIC5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLkltYWdlIgASYAoQc3RyZWFtU2NyZWVuc2hvdBImLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuSW1hZ2VGb3JtYXQaIC5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLkltYWdlIgAwARJhCgtzdHJlYW1BdWRpbxImLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuQXVkaW9Gb3JtYXQaJi5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLkF1ZGlvUGFja2V0IgAwARJRCgtpbmplY3RBdWRpbxImLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuQXVkaW9QYWNrZXQaFi5nb29nbGUucHJvdG9idWYuRW1wdHkiACgBEl4KCWdldExvZ2NhdBIlLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuTG9nTWVzc2FnZRolLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuTG9nTWVzc2FnZSIDiAIBEmAKDHN0cmVhbUxvZ2NhdBIlLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuTG9nTWVzc2FnZRolLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuTG9nTWVzc2FnZSIAMAESTQoKc2V0Vm1TdGF0ZRIlLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuVm1SdW5TdGF0ZRoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eSIAEk0KCmdldFZtU3RhdGUSFi5nb29nbGUucHJvdG9idWYuRW1wdHkaJS5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLlZtUnVuU3RhdGUiABKAAQoYc2V0RGlzcGxheUNvbmZpZ3VyYXRpb25zEjAuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5EaXNwbGF5Q29uZmlndXJhdGlvbnMaMC5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLkRpc3BsYXlDb25maWd1cmF0aW9ucyIAEmYKGGdldERpc3BsYXlDb25maWd1cmF0aW9ucxIWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eRowLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuRGlzcGxheUNvbmZpZ3VyYXRpb25zIgASWQoSc3RyZWFtTm90aWZpY2F0aW9uEhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5GicuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5Ob3RpZmljYXRpb24iADABEl8KGHJvdGF0ZVZpcnR1YWxTY2VuZUNhbWVyYRIpLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuUm90YXRpb25SYWRpYW4aFi5nb29nbGUucHJvdG9idWYuRW1wdHkiABJeCh1zZXRWaXJ0dWFsU2NlbmVDYW1lcmFWZWxvY2l0eRIjLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuVmVsb2NpdHkaFi5nb29nbGUucHJvdG9idWYuRW1wdHkiABJKCgpzZXRQb3N0dXJlEiIuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5Qb3N0dXJlGhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5IgASaQoNZ2V0QnJpZ2h0bmVzcxIqLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuQnJpZ2h0bmVzc1ZhbHVlGiouYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5CcmlnaHRuZXNzVmFsdWUiABJVCg1zZXRCcmlnaHRuZXNzEiouYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5CcmlnaHRuZXNzVmFsdWUaFi5nb29nbGUucHJvdG9idWYuRW1wdHkiABJSCg5nZXREaXNwbGF5TW9kZRIWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eRomLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuRGlzcGxheU1vZGUiABJSCg5zZXREaXNwbGF5TW9kZRImLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuRGlzcGxheU1vZGUaFi5nb29nbGUucHJvdG9idWYuRW1wdHkiAEImChxjb20uYW5kcm9pZC5lbXVsYXRvci5jb250cm9sUAGiAgNBRUNiBnByb3RvMw", [file_google_protobuf_empty]);

/**
 * A Run State that describes the state of the Virtual Machine.
 *
 * @generated from message android.emulation.control.VmRunState
 */
export type VmRunState = Message<"android.emulation.control.VmRunState"> & {
  /**
   * @generated from field: android.emulation.control.VmRunState.RunState state = 1;
   */
  state: VmRunState_RunState;
};

/**
 * Describes the message android.emulation.control.VmRunState.
 * Use `create(VmRunStateSchema)` to create a new message.
 */
export const VmRunStateSchema: GenMessage<VmRunState> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 0);

/**
 * @generated from enum android.emulation.control.VmRunState.RunState
 */
export enum VmRunState_RunState {
  /**
   * The emulator is in an unknown state. You cannot transition to this
   * state.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * Guest is actively running. You can transition to this state from the
   * paused state.
   *
   * @generated from enum value: RUNNING = 1;
   */
  RUNNING = 1,

  /**
   * Guest is paused to load a snapshot. You cannot transition to this
   * state.
   *
   * @generated from enum value: RESTORE_VM = 2;
   */
  RESTORE_VM = 2,

  /**
   * Guest has been paused. Transitioning to this state will pause the
   * emulator the guest will not be consuming any cpu cycles.
   *
   * @generated from enum value: PAUSED = 3;
   */
  PAUSED = 3,

  /**
   * Guest is paused to take or export a snapshot. You cannot
   * transition to this state.
   *
   * @generated from enum value: SAVE_VM = 4;
   */
  SAVE_VM = 4,

  /**
   * System shutdown, note that it is similar to power off. It tries to
   * set the system status and notify guest. The system is likely going to
   * disappear soon and do proper cleanup of resources, possibly taking
   * a snapshot. This is the same behavior as closing the emulator by
   * clicking the X (close) in the user interface.
   *
   * @generated from enum value: SHUTDOWN = 5;
   */
  SHUTDOWN = 5,

  /**
   * Immediately terminate the emulator. No resource cleanup will take
   * place. There is a good change to corrupt the system.
   *
   * @generated from enum value: TERMINATE = 7;
   */
  TERMINATE = 7,

  /**
   * Will cause the emulator to reset. This is not a state you can
   * observe.
   *
   * @generated from enum value: RESET = 9;
   */
  RESET = 9,

  /**
   * Guest experienced some error state, you cannot transition to this
   * state.
   *
   * @generated from enum value: INTERNAL_ERROR = 10;
   */
  INTERNAL_ERROR = 10,

  /**
   * Completely restart the emulator.
   *
   * @generated from enum value: RESTART = 11;
   */
  RESTART = 11,

  /**
   * Resume a stopped emulator
   *
   * @generated from enum value: START = 12;
   */
  START = 12,

  /**
   * Stop (pause) a running emulator
   *
   * @generated from enum value: STOP = 13;
   */
  STOP = 13,
}

/**
 * Describes the enum android.emulation.control.VmRunState.RunState.
 */
export const VmRunState_RunStateSchema: GenEnum<VmRunState_RunState> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 0, 0);

/**
 * @generated from message android.emulation.control.ParameterValue
 */
export type ParameterValue = Message<"android.emulation.control.ParameterValue"> & {
  /**
   * @generated from field: repeated float data = 1 [packed = true];
   */
  data: number[];
};

/**
 * Describes the message android.emulation.control.ParameterValue.
 * Use `create(ParameterValueSchema)` to create a new message.
 */
export const ParameterValueSchema: GenMessage<ParameterValue> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 1);

/**
 * @generated from message android.emulation.control.PhysicalModelValue
 */
export type PhysicalModelValue = Message<"android.emulation.control.PhysicalModelValue"> & {
  /**
   * @generated from field: android.emulation.control.PhysicalModelValue.PhysicalType target = 1;
   */
  target: PhysicalModelValue_PhysicalType;

  /**
   * [Output Only]
   *
   * @generated from field: android.emulation.control.PhysicalModelValue.State status = 2;
   */
  status: PhysicalModelValue_State;

  /**
   * Value interpretation depends on sensor.
   *
   * @generated from field: android.emulation.control.ParameterValue value = 3;
   */
  value?: ParameterValue;
};

/**
 * Describes the message android.emulation.control.PhysicalModelValue.
 * Use `create(PhysicalModelValueSchema)` to create a new message.
 */
export const PhysicalModelValueSchema: GenMessage<PhysicalModelValue> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 2);

/**
 * @generated from enum android.emulation.control.PhysicalModelValue.State
 */
export enum PhysicalModelValue_State {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * qemud service is not available/initiated.
   *
   * @generated from enum value: NO_SERVICE = -3;
   */
  NO_SERVICE = -3,

  /**
   * Sensor is disabled.
   *
   * @generated from enum value: DISABLED = -2;
   */
  DISABLED = -2,

  /**
   * Unknown sensor (should not happen)
   *
   * @generated from enum value: UNKNOWN = -1;
   */
  UNKNOWN = -1,
}

/**
 * Describes the enum android.emulation.control.PhysicalModelValue.State.
 */
export const PhysicalModelValue_StateSchema: GenEnum<PhysicalModelValue_State> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 2, 0);

/**
 * Details on the sensors documentation can be found here:
 * https://developer.android.com/reference/android/hardware/Sensor.html#TYPE_
 * The types must follow the order defined in
 * "external/qemu/android/hw-sensors.h"
 *
 * @generated from enum android.emulation.control.PhysicalModelValue.PhysicalType
 */
export enum PhysicalModelValue_PhysicalType {
  /**
   * @generated from enum value: POSITION = 0;
   */
  POSITION = 0,

  /**
   * All values are angles in degrees.
   * values = [x,y,z]
   *
   * @generated from enum value: ROTATION = 1;
   */
  ROTATION = 1,

  /**
   * @generated from enum value: MAGNETIC_FIELD = 2;
   */
  MAGNETIC_FIELD = 2,

  /**
   * Temperature in °C
   *
   * @generated from enum value: TEMPERATURE = 3;
   */
  TEMPERATURE = 3,

  /**
   * Proximity sensor distance measured in centimeters
   *
   * @generated from enum value: PROXIMITY = 4;
   */
  PROXIMITY = 4,

  /**
   * Ambient light level in SI lux units
   *
   * @generated from enum value: LIGHT = 5;
   */
  LIGHT = 5,

  /**
   * Atmospheric pressure in hPa (millibar)
   *
   * @generated from enum value: PRESSURE = 6;
   */
  PRESSURE = 6,

  /**
   * Relative ambient air humidity in percent
   *
   * @generated from enum value: HUMIDITY = 7;
   */
  HUMIDITY = 7,

  /**
   * @generated from enum value: VELOCITY = 8;
   */
  VELOCITY = 8,

  /**
   * @generated from enum value: AMBIENT_MOTION = 9;
   */
  AMBIENT_MOTION = 9,

  /**
   * Describing a hinge angle sensor in degrees.
   *
   * @generated from enum value: HINGE_ANGLE0 = 10;
   */
  HINGE_ANGLE0 = 10,

  /**
   * @generated from enum value: HINGE_ANGLE1 = 11;
   */
  HINGE_ANGLE1 = 11,

  /**
   * @generated from enum value: HINGE_ANGLE2 = 12;
   */
  HINGE_ANGLE2 = 12,

  /**
   * @generated from enum value: ROLLABLE0 = 13;
   */
  ROLLABLE0 = 13,

  /**
   * @generated from enum value: ROLLABLE1 = 14;
   */
  ROLLABLE1 = 14,

  /**
   * @generated from enum value: ROLLABLE2 = 15;
   */
  ROLLABLE2 = 15,

  /**
   * Describing the device posture; the value should be an enum defined
   * in Posture::PostureValue.
   *
   * @generated from enum value: POSTURE = 16;
   */
  POSTURE = 16,

  /**
   * Heart rate in bpm
   *
   * @generated from enum value: HEART_RATE = 17;
   */
  HEART_RATE = 17,

  /**
   * Ambient RGBC light intensity. Values are in order (Red, Green, Blue,
   * Clear).
   *
   * @generated from enum value: RGBC_LIGHT = 18;
   */
  RGBC_LIGHT = 18,

  /**
   * Wrist tilt gesture (1 = gaze, 0 = ungaze)
   *
   * @generated from enum value: WRIST_TILT = 19;
   */
  WRIST_TILT = 19,
}

/**
 * Describes the enum android.emulation.control.PhysicalModelValue.PhysicalType.
 */
export const PhysicalModelValue_PhysicalTypeSchema: GenEnum<PhysicalModelValue_PhysicalType> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 2, 1);

/**
 * A single sensor value.
 *
 * @generated from message android.emulation.control.SensorValue
 */
export type SensorValue = Message<"android.emulation.control.SensorValue"> & {
  /**
   * Type of sensor
   *
   * @generated from field: android.emulation.control.SensorValue.SensorType target = 1;
   */
  target: SensorValue_SensorType;

  /**
   * [Output Only]
   *
   * @generated from field: android.emulation.control.SensorValue.State status = 2;
   */
  status: SensorValue_State;

  /**
   * Value interpretation depends on sensor enum.
   *
   * @generated from field: android.emulation.control.ParameterValue value = 3;
   */
  value?: ParameterValue;
};

/**
 * Describes the message android.emulation.control.SensorValue.
 * Use `create(SensorValueSchema)` to create a new message.
 */
export const SensorValueSchema: GenMessage<SensorValue> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 3);

/**
 * @generated from enum android.emulation.control.SensorValue.State
 */
export enum SensorValue_State {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * qemud service is not available/initiated.
   *
   * @generated from enum value: NO_SERVICE = -3;
   */
  NO_SERVICE = -3,

  /**
   * Sensor is disabled.
   *
   * @generated from enum value: DISABLED = -2;
   */
  DISABLED = -2,

  /**
   * Unknown sensor (should not happen)
   *
   * @generated from enum value: UNKNOWN = -1;
   */
  UNKNOWN = -1,
}

/**
 * Describes the enum android.emulation.control.SensorValue.State.
 */
export const SensorValue_StateSchema: GenEnum<SensorValue_State> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 3, 0);

/**
 * These are the various sensors that can be available in an emulated
 * devices.
 *
 * @generated from enum android.emulation.control.SensorValue.SensorType
 */
export enum SensorValue_SensorType {
  /**
   * Measures the acceleration force in m/s2 that is applied to a device
   * on all three physical axes (x, y, and z), including the force of
   * gravity.
   *
   * @generated from enum value: ACCELERATION = 0;
   */
  ACCELERATION = 0,

  /**
   * Measures a device's rate of rotation in rad/s around each of the
   * three physical axes (x, y, and z).
   *
   * @generated from enum value: GYROSCOPE = 1;
   */
  GYROSCOPE = 1,

  /**
   * Measures the ambient geomagnetic field for all three physical axes
   * (x, y, z) in μT.
   *
   * @generated from enum value: MAGNETIC_FIELD = 2;
   */
  MAGNETIC_FIELD = 2,

  /**
   * Measures degrees of rotation that a device makes around all three
   * physical axes (x, y, z)
   *
   * @generated from enum value: ORIENTATION = 3;
   */
  ORIENTATION = 3,

  /**
   * Measures the temperature of the device in degrees Celsius (°C).
   *
   * @generated from enum value: TEMPERATURE = 4;
   */
  TEMPERATURE = 4,

  /**
   * Measures the proximity of an object in cm relative to the view screen
   * of a device. This sensor is typically used to determine whether a
   * handset is being held up to a person's ear.
   *
   * @generated from enum value: PROXIMITY = 5;
   */
  PROXIMITY = 5,

  /**
   * Measures the ambient light level (illumination) in lx.
   *
   * @generated from enum value: LIGHT = 6;
   */
  LIGHT = 6,

  /**
   * Measures the ambient air pressure in hPa or mbar.
   *
   * @generated from enum value: PRESSURE = 7;
   */
  PRESSURE = 7,

  /**
   * Measures the relative ambient humidity in percent (%).
   *
   * @generated from enum value: HUMIDITY = 8;
   */
  HUMIDITY = 8,

  /**
   * @generated from enum value: MAGNETIC_FIELD_UNCALIBRATED = 9;
   */
  MAGNETIC_FIELD_UNCALIBRATED = 9,

  /**
   * @generated from enum value: GYROSCOPE_UNCALIBRATED = 10;
   */
  GYROSCOPE_UNCALIBRATED = 10,

  /**
   * Measures the heart rate in bpm.
   *
   * @generated from enum value: HEART_RATE = 14;
   */
  HEART_RATE = 14,

  /**
   * Measures the ambient RGBC light intensity.
   * Values are in order (Red, Green, Blue, Clear).
   *
   * @generated from enum value: RGBC_LIGHT = 15;
   */
  RGBC_LIGHT = 15,

  /**
   * WIRST_TILT (16) is skipped; clients should use get/setPhysicalModel()
   * instead.
   * Measures acceleration force and provides bias data.
   *
   * @generated from enum value: ACCELERATION_UNCALIBRATED = 17;
   */
  ACCELERATION_UNCALIBRATED = 17,
}

/**
 * Describes the enum android.emulation.control.SensorValue.SensorType.
 */
export const SensorValue_SensorTypeSchema: GenEnum<SensorValue_SensorType> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 3, 1);

/**
 * A single backlight brightness value.
 *
 * @generated from message android.emulation.control.BrightnessValue
 */
export type BrightnessValue = Message<"android.emulation.control.BrightnessValue"> & {
  /**
   * Type of light
   *
   * @generated from field: android.emulation.control.BrightnessValue.LightType target = 1;
   */
  target: BrightnessValue_LightType;

  /**
   * Light intensity, ranges from 0-255.
   *
   * @generated from field: uint32 value = 2;
   */
  value: number;
};

/**
 * Describes the message android.emulation.control.BrightnessValue.
 * Use `create(BrightnessValueSchema)` to create a new message.
 */
export const BrightnessValueSchema: GenMessage<BrightnessValue> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 4);

/**
 * @generated from enum android.emulation.control.BrightnessValue.LightType
 */
export enum BrightnessValue_LightType {
  /**
   * Display backlight. This will affect all displays.
   *
   * @generated from enum value: LCD = 0;
   */
  LCD = 0,

  /**
   * @generated from enum value: KEYBOARD = 1;
   */
  KEYBOARD = 1,

  /**
   * @generated from enum value: BUTTON = 2;
   */
  BUTTON = 2,
}

/**
 * Describes the enum android.emulation.control.BrightnessValue.LightType.
 */
export const BrightnessValue_LightTypeSchema: GenEnum<BrightnessValue_LightType> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 4, 0);

/**
 * @generated from message android.emulation.control.DisplayMode
 */
export type DisplayMode = Message<"android.emulation.control.DisplayMode"> & {
  /**
   * @generated from field: android.emulation.control.DisplayModeValue value = 1;
   */
  value: DisplayModeValue;
};

/**
 * Describes the message android.emulation.control.DisplayMode.
 * Use `create(DisplayModeSchema)` to create a new message.
 */
export const DisplayModeSchema: GenMessage<DisplayMode> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 5);

/**
 * @generated from message android.emulation.control.LogMessage
 */
export type LogMessage = Message<"android.emulation.control.LogMessage"> & {
  /**
   * [Output Only] The contents of the log output.
   *
   * @generated from field: string contents = 1;
   */
  contents: string;

  /**
   * The starting byte position of the output that was returned. This
   * should match the start parameter sent with the request. If the serial
   * console output exceeds the size of the buffer, older output will be
   * overwritten by newer content and the start values will be mismatched.
   *
   * @generated from field: int64 start = 2 [deprecated = true];
   * @deprecated
   */
  start: bigint;

  /**
   * [Output Only] The position of the next byte of content from the serial
   * console output. Use this value in the next request as the start
   * parameter.
   *
   * @generated from field: int64 next = 3 [deprecated = true];
   * @deprecated
   */
  next: bigint;

  /**
   * Set the sort of response you are interested it in.
   * It the type is "Parsed" the entries field will contain the parsed
   * results. otherwise the contents field will be set.
   *
   * @generated from field: android.emulation.control.LogMessage.LogType sort = 4;
   */
  sort: LogMessage_LogType;

  /**
   * [Output Only] The parsed logcat entries so far. Only set if sort is
   * set to Parsed
   *
   * @generated from field: repeated android.emulation.control.LogcatEntry entries = 5;
   */
  entries: LogcatEntry[];
};

/**
 * Describes the message android.emulation.control.LogMessage.
 * Use `create(LogMessageSchema)` to create a new message.
 */
export const LogMessageSchema: GenMessage<LogMessage> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 6);

/**
 * @generated from enum android.emulation.control.LogMessage.LogType
 */
export enum LogMessage_LogType {
  /**
   * @generated from enum value: Text = 0;
   */
  Text = 0,

  /**
   * @generated from enum value: Parsed = 1;
   */
  Parsed = 1,
}

/**
 * Describes the enum android.emulation.control.LogMessage.LogType.
 */
export const LogMessage_LogTypeSchema: GenEnum<LogMessage_LogType> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 6, 0);

/**
 * A parsed logcat entry.
 *
 * @generated from message android.emulation.control.LogcatEntry
 */
export type LogcatEntry = Message<"android.emulation.control.LogcatEntry"> & {
  /**
   * A Unix timestamps in  milliseconds (The number of milliseconds that
   * have elapsed since January 1, 1970 (midnight UTC/GMT), not counting
   * leap seconds)
   *
   * @generated from field: uint64 timestamp = 1;
   */
  timestamp: bigint;

  /**
   * Process id.
   *
   * @generated from field: uint32 pid = 2;
   */
  pid: number;

  /**
   * Thread id.
   *
   * @generated from field: uint32 tid = 3;
   */
  tid: number;

  /**
   * @generated from field: android.emulation.control.LogcatEntry.LogLevel level = 4;
   */
  level: LogcatEntry_LogLevel;

  /**
   * @generated from field: string tag = 5;
   */
  tag: string;

  /**
   * @generated from field: string msg = 6;
   */
  msg: string;
};

/**
 * Describes the message android.emulation.control.LogcatEntry.
 * Use `create(LogcatEntrySchema)` to create a new message.
 */
export const LogcatEntrySchema: GenMessage<LogcatEntry> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 7);

/**
 * The possible log levels.
 *
 * @generated from enum android.emulation.control.LogcatEntry.LogLevel
 */
export enum LogcatEntry_LogLevel {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: DEFAULT = 1;
   */
  DEFAULT = 1,

  /**
   * @generated from enum value: VERBOSE = 2;
   */
  VERBOSE = 2,

  /**
   * @generated from enum value: DEBUG = 3;
   */
  DEBUG = 3,

  /**
   * @generated from enum value: INFO = 4;
   */
  INFO = 4,

  /**
   * @generated from enum value: WARN = 5;
   */
  WARN = 5,

  /**
   * @generated from enum value: ERR = 6;
   */
  ERR = 6,

  /**
   * @generated from enum value: FATAL = 7;
   */
  FATAL = 7,

  /**
   * @generated from enum value: SILENT = 8;
   */
  SILENT = 8,
}

/**
 * Describes the enum android.emulation.control.LogcatEntry.LogLevel.
 */
export const LogcatEntry_LogLevelSchema: GenEnum<LogcatEntry_LogLevel> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 7, 0);

/**
 * Information about the hypervisor that is currently in use.
 *
 * @generated from message android.emulation.control.VmConfiguration
 */
export type VmConfiguration = Message<"android.emulation.control.VmConfiguration"> & {
  /**
   * @generated from field: android.emulation.control.VmConfiguration.VmHypervisorType hypervisorType = 1;
   */
  hypervisorType: VmConfiguration_VmHypervisorType;

  /**
   * @generated from field: int32 numberOfCpuCores = 2;
   */
  numberOfCpuCores: number;

  /**
   * @generated from field: int64 ramSizeBytes = 3;
   */
  ramSizeBytes: bigint;
};

/**
 * Describes the message android.emulation.control.VmConfiguration.
 * Use `create(VmConfigurationSchema)` to create a new message.
 */
export const VmConfigurationSchema: GenMessage<VmConfiguration> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 8);

/**
 * @generated from enum android.emulation.control.VmConfiguration.VmHypervisorType
 */
export enum VmConfiguration_VmHypervisorType {
  /**
   * An unknown hypervisor
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * No hypervisor is in use. This usually means that the guest is
   * running on a different CPU than the host, or you are using a
   * platform where no hypervisor is available.
   *
   * @generated from enum value: NONE = 1;
   */
  NONE = 1,

  /**
   * The Kernel based Virtual Machine
   * (https://www.linux-kvm.org/page/Main_Page)
   *
   * @generated from enum value: KVM = 2;
   */
  KVM = 2,

  /**
   * Intel® Hardware Accelerated Execution Manager (Intel® HAXM)
   * https://github.com/intel/haxm
   *
   * @generated from enum value: HAXM = 3;
   */
  HAXM = 3,

  /**
   * Hypervisor Framework.
   * https://developer.apple.com/documentation/hypervisor
   *
   * @generated from enum value: HVF = 4;
   */
  HVF = 4,

  /**
   * Window Hypervisor Platform
   * https://docs.microsoft.com/en-us/virtualization/api/
   *
   * @generated from enum value: WHPX = 5;
   */
  WHPX = 5,

  /**
   * @generated from enum value: AEHD = 6;
   */
  AEHD = 6,
}

/**
 * Describes the enum android.emulation.control.VmConfiguration.VmHypervisorType.
 */
export const VmConfiguration_VmHypervisorTypeSchema: GenEnum<VmConfiguration_VmHypervisorType> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 8, 0);

/**
 * Representation of a clipped data object on the clipboard.
 *
 * @generated from message android.emulation.control.ClipData
 */
export type ClipData = Message<"android.emulation.control.ClipData"> & {
  /**
   * UTF-8 Encoded text.
   *
   * @generated from field: string text = 1;
   */
  text: string;
};

/**
 * Describes the message android.emulation.control.ClipData.
 * Use `create(ClipDataSchema)` to create a new message.
 */
export const ClipDataSchema: GenMessage<ClipData> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 9);

/**
 * The Touch interface represents a single contact point on a
 * touch-sensitive device. The contact point is commonly a finger or stylus
 * and the device may be a touchscreen or trackpad.
 *
 * @generated from message android.emulation.control.Touch
 */
export type Touch = Message<"android.emulation.control.Touch"> & {
  /**
   * The horizontal coordinate. This is the physical location on the
   * screen For example 0 indicates the leftmost coordinate.
   *
   * @generated from field: int32 x = 1;
   */
  x: number;

  /**
   * The vertical coordinate. This is the physical location on the screen
   * For example 0 indicates the top left coordinate.
   *
   * @generated from field: int32 y = 2;
   */
  y: number;

  /**
   * The identifier is an arbitrary non-negative integer that is used to
   * identify and track each tool independently when multiple tools are
   * active. For example, when multiple fingers are touching the device,
   * each finger should be assigned a distinct tracking id that is used as
   * long as the finger remains in contact. Tracking ids may be reused
   * when their associated tools move out of range.
   *
   * The emulator currently supports up to 10 concurrent touch events. The
   * identifier can be any uninque value and will be mapped to the next
   * available internal identifier.
   *
   * @generated from field: int32 identifier = 3;
   */
  identifier: number;

  /**
   * Reports the physical pressure applied to the tip of the tool or the
   * signal strength of the touch contact.
   *
   * The values reported must be non-zero when the tool is touching the
   * device and zero otherwise to indicate that the touch event is
   * completed.
   *
   * Make sure to deliver a pressure of 0 for the given identifier when
   * the touch event is completed, otherwise the touch identifier will not
   * be unregistered!
   *
   * @generated from field: int32 pressure = 4;
   */
  pressure: number;

  /**
   * Optionally reports the cross-sectional area of the touch contact, or
   * the length of the longer dimension of the touch contact.
   *
   * @generated from field: int32 touch_major = 5;
   */
  touchMajor: number;

  /**
   * Optionally reports the length of the shorter dimension of the touch
   * contact. This axis will be ignored if touch_major is reporting an
   * area measurement greater than 0.
   *
   * @generated from field: int32 touch_minor = 6;
   */
  touchMinor: number;

  /**
   * @generated from field: android.emulation.control.Touch.EventExpiration expiration = 7;
   */
  expiration: Touch_EventExpiration;

  /**
   * The orientation of the contact, if any.
   *
   * @generated from field: int32 orientation = 8;
   */
  orientation: number;
};

/**
 * Describes the message android.emulation.control.Touch.
 * Use `create(TouchSchema)` to create a new message.
 */
export const TouchSchema: GenMessage<Touch> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 10);

/**
 * @generated from enum android.emulation.control.Touch.EventExpiration
 */
export enum Touch_EventExpiration {
  /**
   * The system will use the default time of 120s to track
   * the touch event with the given identifier. If no update happens
   * within this timeframe the identifier is considered expired
   * and can be made available for re-use. This means that a touch event
   * with pressure 0 for this identifier will be send to the emulator.
   *
   * @generated from enum value: EVENT_EXPIRATION_UNSPECIFIED = 0;
   */
  EVENT_EXPIRATION_UNSPECIFIED = 0,

  /**
   * Never expire the given slot. You must *ALWAYS* close the identifier
   * by sending a touch event with 0 pressure.
   *
   * @generated from enum value: NEVER_EXPIRE = 1;
   */
  NEVER_EXPIRE = 1,
}

/**
 * Describes the enum android.emulation.control.Touch.EventExpiration.
 */
export const Touch_EventExpirationSchema: GenEnum<Touch_EventExpiration> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 10, 0);

/**
 * A Pen is similar to a touch, with the addition
 * of button and rubber information.
 *
 * @generated from message android.emulation.control.Pen
 */
export type Pen = Message<"android.emulation.control.Pen"> & {
  /**
   * @generated from field: android.emulation.control.Touch location = 1;
   */
  location?: Touch;

  /**
   * True if the button is pressed or not
   *
   * @generated from field: bool button_pressed = 2;
   */
  buttonPressed: boolean;

  /**
   * True if it is a rubber pointer.
   *
   * @generated from field: bool rubber_pointer = 3;
   */
  rubberPointer: boolean;
};

/**
 * Describes the message android.emulation.control.Pen.
 * Use `create(PenSchema)` to create a new message.
 */
export const PenSchema: GenMessage<Pen> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 11);

/**
 * A TouchEvent contains a list of Touch objects that are in contact with
 * the touch surface.
 *
 * Touch events are delivered in sequence as specified in the touchList.
 *
 * TouchEvents are delivered to the emulated devices using ["Protocol
 * B"](https://www.kernel.org/doc/Documentation/input/multi-touch-protocol.txt)
 *
 * @generated from message android.emulation.control.TouchEvent
 */
export type TouchEvent = Message<"android.emulation.control.TouchEvent"> & {
  /**
   * The list of Touch objects, note that these do not need to be unique
   *
   * @generated from field: repeated android.emulation.control.Touch touches = 1;
   */
  touches: Touch[];

  /**
   * The display device where the touch event occurred.
   * Omitting or using the value 0 indicates the main display.
   *
   * @generated from field: int32 display = 2;
   */
  display: number;
};

/**
 * Describes the message android.emulation.control.TouchEvent.
 * Use `create(TouchEventSchema)` to create a new message.
 */
export const TouchEventSchema: GenMessage<TouchEvent> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 12);

/**
 * @generated from message android.emulation.control.PenEvent
 */
export type PenEvent = Message<"android.emulation.control.PenEvent"> & {
  /**
   * The list of Pen objects, note that these do not need to be unique
   *
   * @generated from field: repeated android.emulation.control.Pen events = 1;
   */
  events: Pen[];

  /**
   * The display device where the pen event occurred.
   * Omitting or using the value 0 indicates the main display.
   *
   * @generated from field: int32 display = 2;
   */
  display: number;
};

/**
 * Describes the message android.emulation.control.PenEvent.
 * Use `create(PenEventSchema)` to create a new message.
 */
export const PenEventSchema: GenMessage<PenEvent> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 13);

/**
 * The MouseEvent interface represents events that occur due to the user
 * interacting with a pointing device (such as a mouse).
 *
 * @generated from message android.emulation.control.MouseEvent
 */
export type MouseEvent = Message<"android.emulation.control.MouseEvent"> & {
  /**
   * The horizontal coordinate. This is the physical location on the
   * screen For example 0 indicates the leftmost coordinate.
   *
   * @generated from field: int32 x = 1;
   */
  x: number;

  /**
   * The vertical coordinate. This is the physical location on the screen
   * For example 0 indicates the top left coordinate.
   *
   * @generated from field: int32 y = 2;
   */
  y: number;

  /**
   * Indicates which buttons are pressed.
   * 0: No button was pressed
   * 1: Primary button (left)
   * 2: Secondary button (right)
   *
   * @generated from field: int32 buttons = 3;
   */
  buttons: number;

  /**
   * The display device where the mouse event occurred.
   * Omitting or using the value 0 indicates the main display.
   *
   * @generated from field: int32 display = 4;
   */
  display: number;
};

/**
 * Describes the message android.emulation.control.MouseEvent.
 * Use `create(MouseEventSchema)` to create a new message.
 */
export const MouseEventSchema: GenMessage<MouseEvent> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 14);

/**
 * @generated from message android.emulation.control.WheelEvent
 */
export type WheelEvent = Message<"android.emulation.control.WheelEvent"> & {
  /**
   * The value indicating how much the mouse wheel is rotated. Scaled so that
   * 120 equals to 1 wheel click. (120 is chosen as a multiplier often used to
   * represent wheel movements less than 1 wheel click. e.g.
   * https://doc.qt.io/qt-5/qwheelevent.html#angleDelta) Positive delta value
   * is assigned to dx when the top of wheel is moved to left. Similarly
   * positive delta value is assigned to dy when the top of wheel is moved
   * away from the user.
   *
   * @generated from field: int32 dx = 1;
   */
  dx: number;

  /**
   * @generated from field: int32 dy = 2;
   */
  dy: number;

  /**
   * The display device where the mouse event occurred.
   * Omitting or using the value 0 indicates the main display.
   *
   * @generated from field: int32 display = 3;
   */
  display: number;
};

/**
 * Describes the message android.emulation.control.WheelEvent.
 * Use `create(WheelEventSchema)` to create a new message.
 */
export const WheelEventSchema: GenMessage<WheelEvent> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 15);

/**
 * KeyboardEvent objects describe a user interaction with the keyboard; each
 * event describes a single interaction between the user and a key (or
 * combination of a key with modifier keys) on the keyboard.
 * This follows the pattern as set by
 * (javascript)[https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent]
 *
 * Note: that only keyCode, key, or text can be set and that the semantics
 * will slightly vary.
 *
 * @generated from message android.emulation.control.KeyboardEvent
 */
export type KeyboardEvent = Message<"android.emulation.control.KeyboardEvent"> & {
  /**
   * Type of keycode contained in the keyCode field.
   *
   * @generated from field: android.emulation.control.KeyboardEvent.KeyCodeType codeType = 1;
   */
  codeType: KeyboardEvent_KeyCodeType;

  /**
   * The type of keyboard event that should be sent to the emulator
   *
   * @generated from field: android.emulation.control.KeyboardEvent.KeyEventType eventType = 2;
   */
  eventType: KeyboardEvent_KeyEventType;

  /**
   * This property represents a physical key on the keyboard (as opposed
   * to the character generated by pressing the key). In other words, this
   * property is a value which isn't altered by keyboard layout or the
   * state of the modifier keys. This value will be interpreted by the
   * emulator depending on the KeyCodeType. The incoming key code will be
   * translated to an evdev code type and send to the emulator.
   * The values in key and text will be ignored.
   *
   * @generated from field: int32 keyCode = 3;
   */
  keyCode: number;

  /**
   * The value of the key pressed by the user, taking into consideration
   * the state of modifier keys such as Shift as well as the keyboard
   * locale and layout. This follows the w3c standard used in browsers.
   * You can find an accurate description of valid values
   * [here](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values)
   *
   * Note that some keys can result in multiple evdev events that are
   * delivered to the emulator. for example the Key "A" will result in a
   * sequence:
   * ["Shift", "a"] -> [0x2a, 0x1e] whereas "a" results in ["a"] -> [0x1e].
   *
   * Not all documented keys are understood by android, and only printable
   * ASCII [32-127) characters are properly translated.
   *
   * Keep in mind that there are a set of key values that result in android
   * specific behavior
   * [see](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values#Phone_keys):
   *
   * - "AppSwitch": Behaves as the "Overview" button in android.
   * - "GoBack": The Back button.
   * - "GoHome": The Home button, which takes the user to the phone's main
   *             screen (usually an application launcher).
   * - "Power":  The Power button.
   *
   * @generated from field: string key = 4;
   */
  key: string;

  /**
   * Series of utf8 encoded characters to send to the emulator. An attempt
   * will be made to translate every character will an EvDev event type and
   * send to the emulator as a keypress event. The values in keyCode,
   * eventType, codeType and key will be ignored.
   *
   * Note that most printable ASCII characters (range [32-127) can be send
   * individually with the "key" param. Do not expect arbitrary UTF symbols to
   * arrive in the emulator (most will be ignored).
   *
   * Note that it is possible to overrun the keyboard buffer by slamming this
   * endpoint with large quantities of text (>1kb). The clipboard api is
   * better suited for transferring large quantities of text.
   *
   * @generated from field: string text = 5;
   */
  text: string;
};

/**
 * Describes the message android.emulation.control.KeyboardEvent.
 * Use `create(KeyboardEventSchema)` to create a new message.
 */
export const KeyboardEventSchema: GenMessage<KeyboardEvent> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 16);

/**
 * Code types that the emulator can receive. Note that the emulator
 * will do its best to translate the code to an evdev value that
 * will be send to the emulator. This translation is based on
 * the chromium translation tables. See
 * (this)[https://android.googlesource.com/platform/external/qemu/+/refs/heads/emu-master-dev/android/android-grpc/android/emulation/control/keyboard/keycode_converter_data.inc]
 * for details on the translation.
 *
 * @generated from enum android.emulation.control.KeyboardEvent.KeyCodeType
 */
export enum KeyboardEvent_KeyCodeType {
  /**
   * @generated from enum value: Usb = 0;
   */
  Usb = 0,

  /**
   * @generated from enum value: Evdev = 1;
   */
  Evdev = 1,

  /**
   * @generated from enum value: XKB = 2;
   */
  XKB = 2,

  /**
   * @generated from enum value: Win = 3;
   */
  Win = 3,

  /**
   * @generated from enum value: Mac = 4;
   */
  Mac = 4,
}

/**
 * Describes the enum android.emulation.control.KeyboardEvent.KeyCodeType.
 */
export const KeyboardEvent_KeyCodeTypeSchema: GenEnum<KeyboardEvent_KeyCodeType> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 16, 0);

/**
 * @generated from enum android.emulation.control.KeyboardEvent.KeyEventType
 */
export enum KeyboardEvent_KeyEventType {
  /**
   * Indicates that this keyevent should be send to the emulator
   * as a key down event. Meaning that the key event will be
   * translated to an EvDev event type and bit 11 (0x400) will be
   * set before it is sent to the emulator.
   *
   * @generated from enum value: keydown = 0;
   */
  keydown = 0,

  /**
   * Indicates that the keyevent should be send to the emulator
   * as a key up event. Meaning that the key event will be
   * translated to an EvDev event type and
   * sent to the emulator.
   *
   * @generated from enum value: keyup = 1;
   */
  keyup = 1,

  /**
   * Indicates that the keyevent will be send to the emulator
   * as e key down event and immediately followed by a keyup event.
   *
   * @generated from enum value: keypress = 2;
   */
  keypress = 2,
}

/**
 * Describes the enum android.emulation.control.KeyboardEvent.KeyEventType.
 */
export const KeyboardEvent_KeyEventTypeSchema: GenEnum<KeyboardEvent_KeyEventType> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 16, 1);

/**
 * An input event that can be delivered to the emulator.
 *
 * @generated from message android.emulation.control.InputEvent
 */
export type InputEvent = Message<"android.emulation.control.InputEvent"> & {
  /**
   * @generated from oneof android.emulation.control.InputEvent.type
   */
  type: {
    /**
     * @generated from field: android.emulation.control.KeyboardEvent key_event = 1;
     */
    value: KeyboardEvent;
    case: "keyEvent";
  } | {
    /**
     * @generated from field: android.emulation.control.TouchEvent touch_event = 2;
     */
    value: TouchEvent;
    case: "touchEvent";
  } | {
    /**
     * @generated from field: android.emulation.control.MouseEvent mouse_event = 3;
     */
    value: MouseEvent;
    case: "mouseEvent";
  } | {
    /**
     * @generated from field: android.emulation.control.AndroidEvent android_event = 4;
     */
    value: AndroidEvent;
    case: "androidEvent";
  } | {
    /**
     * @generated from field: android.emulation.control.PenEvent pen_event = 5;
     */
    value: PenEvent;
    case: "penEvent";
  } | {
    /**
     * @generated from field: android.emulation.control.WheelEvent wheel_event = 6;
     */
    value: WheelEvent;
    case: "wheelEvent";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message android.emulation.control.InputEvent.
 * Use `create(InputEventSchema)` to create a new message.
 */
export const InputEventSchema: GenMessage<InputEvent> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 17);

/**
 * The android input event system is a framework for handling input from a
 * variety of devices by generating events that describe changes in the
 * state of the devices and forwarding them to user space applications.
 *
 * An AndroidEvents will be delivered directly to the kernel as is.
 *
 * @generated from message android.emulation.control.AndroidEvent
 */
export type AndroidEvent = Message<"android.emulation.control.AndroidEvent"> & {
  /**
   * The type of the event. The types of the event are specified
   * by the android kernel. Some examples are:
   * EV_SYN, EV_KEY, EV_SW, etc..
   * The exact definitions can be found in the input.h header file.
   *
   * @generated from field: int32 type = 1;
   */
  type: number;

  /**
   * The actual code to be send to the kernel. The actual meaning
   * of the code depends on the type definition.
   *
   * @generated from field: int32 code = 2;
   */
  code: number;

  /**
   * The actual value of the event.
   *
   * @generated from field: int32 value = 3;
   */
  value: number;

  /**
   * The display id associated with this input event.
   *
   * @generated from field: int32 display = 4;
   */
  display: number;
};

/**
 * Describes the message android.emulation.control.AndroidEvent.
 * Use `create(AndroidEventSchema)` to create a new message.
 */
export const AndroidEventSchema: GenMessage<AndroidEvent> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 18);

/**
 * @generated from message android.emulation.control.Fingerprint
 */
export type Fingerprint = Message<"android.emulation.control.Fingerprint"> & {
  /**
   * True when the fingprint is touched.
   *
   * @generated from field: bool isTouching = 1;
   */
  isTouching: boolean;

  /**
   * The identifier of the registered fingerprint.
   *
   * @generated from field: int32 touchId = 2;
   */
  touchId: number;
};

/**
 * Describes the message android.emulation.control.Fingerprint.
 * Use `create(FingerprintSchema)` to create a new message.
 */
export const FingerprintSchema: GenMessage<Fingerprint> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 19);

/**
 * @generated from message android.emulation.control.GpsState
 */
export type GpsState = Message<"android.emulation.control.GpsState"> & {
  /**
   * Setting this to false will disable auto updating  from the LocationUI,
   * otherwise the location UI will override the location at a frequency of
   * 1hz.
   *
   * - This is unused if the emulator is launched with -no-window, or when he
   *   location ui is disabled.
   * - This will BREAK the location ui experience if it is set to false. For
   *    example routing will no longer function.
   *
   * @generated from field: bool passiveUpdate = 1;
   */
  passiveUpdate: boolean;

  /**
   * The latitude, in degrees.
   *
   * @generated from field: double latitude = 2;
   */
  latitude: number;

  /**
   * The longitude, in degrees.
   *
   * @generated from field: double longitude = 3;
   */
  longitude: number;

  /**
   * The speed if it is available, in meters/second over ground
   *
   * @generated from field: double speed = 4;
   */
  speed: number;

  /**
   * gets the horizontal direction of travel of this device, and is not
   * related to the device orientation. It is guaranteed to be in the
   * range [0.0, 360.0] if the device has a bearing. 0=North, 90=East,
   * 180=South, etc..
   *
   * @generated from field: double bearing = 5;
   */
  bearing: number;

  /**
   * The altitude if available, in meters above the WGS 84 reference
   * ellipsoid.
   *
   * @generated from field: double altitude = 6;
   */
  altitude: number;

  /**
   * The number of satellites used to derive the fix
   *
   * @generated from field: int32 satellites = 7;
   */
  satellites: number;
};

/**
 * Describes the message android.emulation.control.GpsState.
 * Use `create(GpsStateSchema)` to create a new message.
 */
export const GpsStateSchema: GenMessage<GpsState> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 20);

/**
 * @generated from message android.emulation.control.BatteryState
 */
export type BatteryState = Message<"android.emulation.control.BatteryState"> & {
  /**
   * @generated from field: bool hasBattery = 1;
   */
  hasBattery: boolean;

  /**
   * @generated from field: bool isPresent = 2;
   */
  isPresent: boolean;

  /**
   * @generated from field: android.emulation.control.BatteryState.BatteryCharger charger = 3;
   */
  charger: BatteryState_BatteryCharger;

  /**
   * @generated from field: int32 chargeLevel = 4;
   */
  chargeLevel: number;

  /**
   * @generated from field: android.emulation.control.BatteryState.BatteryHealth health = 5;
   */
  health: BatteryState_BatteryHealth;

  /**
   * @generated from field: android.emulation.control.BatteryState.BatteryStatus status = 6;
   */
  status: BatteryState_BatteryStatus;
};

/**
 * Describes the message android.emulation.control.BatteryState.
 * Use `create(BatteryStateSchema)` to create a new message.
 */
export const BatteryStateSchema: GenMessage<BatteryState> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 21);

/**
 * @generated from enum android.emulation.control.BatteryState.BatteryStatus
 */
export enum BatteryState_BatteryStatus {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: CHARGING = 1;
   */
  CHARGING = 1,

  /**
   * @generated from enum value: DISCHARGING = 2;
   */
  DISCHARGING = 2,

  /**
   * @generated from enum value: NOT_CHARGING = 3;
   */
  NOT_CHARGING = 3,

  /**
   * @generated from enum value: FULL = 4;
   */
  FULL = 4,
}

/**
 * Describes the enum android.emulation.control.BatteryState.BatteryStatus.
 */
export const BatteryState_BatteryStatusSchema: GenEnum<BatteryState_BatteryStatus> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 21, 0);

/**
 * @generated from enum android.emulation.control.BatteryState.BatteryCharger
 */
export enum BatteryState_BatteryCharger {
  /**
   * @generated from enum value: NONE = 0;
   */
  NONE = 0,

  /**
   * @generated from enum value: AC = 1;
   */
  AC = 1,

  /**
   * @generated from enum value: USB = 2;
   */
  USB = 2,

  /**
   * @generated from enum value: WIRELESS = 3;
   */
  WIRELESS = 3,
}

/**
 * Describes the enum android.emulation.control.BatteryState.BatteryCharger.
 */
export const BatteryState_BatteryChargerSchema: GenEnum<BatteryState_BatteryCharger> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 21, 1);

/**
 * @generated from enum android.emulation.control.BatteryState.BatteryHealth
 */
export enum BatteryState_BatteryHealth {
  /**
   * @generated from enum value: GOOD = 0;
   */
  GOOD = 0,

  /**
   * @generated from enum value: FAILED = 1;
   */
  FAILED = 1,

  /**
   * @generated from enum value: DEAD = 2;
   */
  DEAD = 2,

  /**
   * @generated from enum value: OVERVOLTAGE = 3;
   */
  OVERVOLTAGE = 3,

  /**
   * @generated from enum value: OVERHEATED = 4;
   */
  OVERHEATED = 4,
}

/**
 * Describes the enum android.emulation.control.BatteryState.BatteryHealth.
 */
export const BatteryState_BatteryHealthSchema: GenEnum<BatteryState_BatteryHealth> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 21, 2);

/**
 * An ImageTransport allows for specifying a side channel for
 * delivering image frames versus using the standard bytes array that is
 * returned with the gRPC request.
 *
 * @generated from message android.emulation.control.ImageTransport
 */
export type ImageTransport = Message<"android.emulation.control.ImageTransport"> & {
  /**
   * The desired transport channel used for delivering image frames. Only
   * relevant when streaming screenshots.
   *
   * @generated from field: android.emulation.control.ImageTransport.TransportChannel channel = 1;
   */
  channel: ImageTransport_TransportChannel;

  /**
   * Handle used for writing image frames if transport is mmap. The client
   * sets and owns this handle. It can be either a shm region, or a mmap. A
   * mmap should be a url that starts with `file:///` Note: the mmap can
   * result in tearing.
   *
   * @generated from field: string handle = 2;
   */
  handle: string;
};

/**
 * Describes the message android.emulation.control.ImageTransport.
 * Use `create(ImageTransportSchema)` to create a new message.
 */
export const ImageTransportSchema: GenMessage<ImageTransport> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 22);

/**
 * @generated from enum android.emulation.control.ImageTransport.TransportChannel
 */
export enum ImageTransport_TransportChannel {
  /**
   * Return full frames over the gRPC transport
   *
   * @generated from enum value: TRANSPORT_CHANNEL_UNSPECIFIED = 0;
   */
  TRANSPORT_CHANNEL_UNSPECIFIED = 0,

  /**
   * Write images to the a file/shared memory handle.
   *
   * @generated from enum value: MMAP = 1;
   */
  MMAP = 1,
}

/**
 * Describes the enum android.emulation.control.ImageTransport.TransportChannel.
 */
export const ImageTransport_TransportChannelSchema: GenEnum<ImageTransport_TransportChannel> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 22, 0);

/**
 * The aspect ratio (width/height) will be different from the one
 * where the device is unfolded.
 *
 * @generated from message android.emulation.control.FoldedDisplay
 */
export type FoldedDisplay = Message<"android.emulation.control.FoldedDisplay"> & {
  /**
   * @generated from field: uint32 width = 1;
   */
  width: number;

  /**
   * @generated from field: uint32 height = 2;
   */
  height: number;

  /**
   * It is possible for the screen to be folded in different ways depending
   * on which surface is shown to the user. So xOffset and yOffset indicate
   * the top left corner of the folded screen within the original unfolded
   * screen.
   *
   * @generated from field: uint32 xOffset = 3;
   */
  xOffset: number;

  /**
   * @generated from field: uint32 yOffset = 4;
   */
  yOffset: number;
};

/**
 * Describes the message android.emulation.control.FoldedDisplay.
 * Use `create(FoldedDisplaySchema)` to create a new message.
 */
export const FoldedDisplaySchema: GenMessage<FoldedDisplay> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 23);

/**
 * @generated from message android.emulation.control.ImageFormat
 */
export type ImageFormat = Message<"android.emulation.control.ImageFormat"> & {
  /**
   * The (desired) format of the resulting bytes.
   *
   * @generated from field: android.emulation.control.ImageFormat.ImgFormat format = 1;
   */
  format: ImageFormat_ImgFormat;

  /**
   * [Output Only] The rotation of the image. The image will be rotated
   * based upon the coarse grained orientation of the device.
   *
   * @generated from field: android.emulation.control.Rotation rotation = 2;
   */
  rotation?: Rotation;

  /**
   * The (desired) width of the image. When passed as input
   * the image will be scaled to match the given
   * width, while maintaining the aspect ratio of the device.
   * The returned image will never exceed the given width, but can be less.
   * Omitting this value (or passing in 0) will result in no scaling,
   * and the width of the actual device will be used.
   *
   * @generated from field: uint32 width = 3;
   */
  width: number;

  /**
   * The (desired) height of the image.  When passed as input
   * the image will be scaled to match the given
   * height, while maintaining the aspect ratio of the device.
   * The returned image will never exceed the given height, but can be less.
   * Omitting this value (or passing in 0) will result in no scaling,
   * and the height of the actual device will be used.
   *
   * @generated from field: uint32 height = 4;
   */
  height: number;

  /**
   * The (desired) display id of the device. Setting this to 0 (or omitting)
   * indicates the main display.
   *
   * @generated from field: uint32 display = 5;
   */
  display: number;

  /**
   * Set this if you wish to use a different transport channel to deliver
   * image frames.
   *
   * @generated from field: android.emulation.control.ImageTransport transport = 6;
   */
  transport?: ImageTransport;

  /**
   * [Output Only] Display configuration when screen is folded. The value is
   * the original configuration before scaling.
   *
   * @generated from field: android.emulation.control.FoldedDisplay foldedDisplay = 7;
   */
  foldedDisplay?: FoldedDisplay;

  /**
   * [Output Only] Display mode when AVD is resizable.
   *
   * @generated from field: android.emulation.control.DisplayModeValue displayMode = 8;
   */
  displayMode: DisplayModeValue;
};

/**
 * Describes the message android.emulation.control.ImageFormat.
 * Use `create(ImageFormatSchema)` to create a new message.
 */
export const ImageFormatSchema: GenMessage<ImageFormat> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 24);

/**
 * @generated from enum android.emulation.control.ImageFormat.ImgFormat
 */
export enum ImageFormat_ImgFormat {
  /**
   * Portable Network Graphics format
   * (https://en.wikipedia.org/wiki/Portable_Network_Graphics)
   *
   * @generated from enum value: PNG = 0;
   */
  PNG = 0,

  /**
   * Three-channel RGB color model supplemented with a fourth alpha
   * channel. https://en.wikipedia.org/wiki/RGBA_color_model
   * Each pixel consists of 4 bytes.
   *
   * @generated from enum value: RGBA8888 = 1;
   */
  RGBA8888 = 1,

  /**
   * Three-channel RGB color model, each pixel consists of 3 bytes
   *
   * @generated from enum value: RGB888 = 2;
   */
  RGB888 = 2,
}

/**
 * Describes the enum android.emulation.control.ImageFormat.ImgFormat.
 */
export const ImageFormat_ImgFormatSchema: GenEnum<ImageFormat_ImgFormat> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 24, 0);

/**
 * @generated from message android.emulation.control.Image
 */
export type Image = Message<"android.emulation.control.Image"> & {
  /**
   * @generated from field: android.emulation.control.ImageFormat format = 1;
   */
  format?: ImageFormat;

  /**
   * width is contained in format.
   *
   * @generated from field: uint32 width = 2 [deprecated = true];
   * @deprecated
   */
  width: number;

  /**
   * height is contained in format.
   *
   * @generated from field: uint32 height = 3 [deprecated = true];
   * @deprecated
   */
  height: number;

  /**
   * The organization of the pixels in the image buffer is from left to
   * right and bottom up. This will be empty if an alternative image transport
   * is requested in the image format. In that case the side channel should
   * be used to obtain the image data.
   *
   * @generated from field: bytes image = 4;
   */
  image: Uint8Array;

  /**
   * [Output Only] Monotonically increasing sequence number in a stream of
   * screenshots. The first screenshot will have a sequence of 0. A single
   * screenshot will always have a sequence number of 0. The sequence is not
   * necessarily contiguous, and can be used to detect how many frames were
   * dropped. An example sequence could be: [0, 3, 5, 7, 9, 11].
   *
   * @generated from field: uint32 seq = 5;
   */
  seq: number;

  /**
   * [Output Only] Unix timestamp in microseconds when the emulator estimates
   * the frame was generated. The timestamp is before the actual frame is
   * copied and transformed. This can be used to calculate variance between
   * frame production time, and frame depiction time.
   *
   * @generated from field: uint64 timestampUs = 6;
   */
  timestampUs: bigint;
};

/**
 * Describes the message android.emulation.control.Image.
 * Use `create(ImageSchema)` to create a new message.
 */
export const ImageSchema: GenMessage<Image> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 25);

/**
 * @generated from message android.emulation.control.Rotation
 */
export type Rotation = Message<"android.emulation.control.Rotation"> & {
  /**
   * The rotation of the device, derived from the sensor state
   * of the emulator. The derivation reflects how android observes
   * the rotation state.
   *
   * @generated from field: android.emulation.control.Rotation.SkinRotation rotation = 1;
   */
  rotation: Rotation_SkinRotation;

  /**
   * Specifies the angle of rotation, in degrees [-180, 180]
   *
   * @generated from field: double xAxis = 2;
   */
  xAxis: number;

  /**
   * @generated from field: double yAxis = 3;
   */
  yAxis: number;

  /**
   * @generated from field: double zAxis = 4;
   */
  zAxis: number;
};

/**
 * Describes the message android.emulation.control.Rotation.
 * Use `create(RotationSchema)` to create a new message.
 */
export const RotationSchema: GenMessage<Rotation> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 26);

/**
 * @generated from enum android.emulation.control.Rotation.SkinRotation
 */
export enum Rotation_SkinRotation {
  /**
   * 0 degrees
   *
   * @generated from enum value: PORTRAIT = 0;
   */
  PORTRAIT = 0,

  /**
   * 90 degrees
   *
   * @generated from enum value: LANDSCAPE = 1;
   */
  LANDSCAPE = 1,

  /**
   * -180 degrees
   *
   * @generated from enum value: REVERSE_PORTRAIT = 2;
   */
  REVERSE_PORTRAIT = 2,

  /**
   * -90 degrees
   *
   * @generated from enum value: REVERSE_LANDSCAPE = 3;
   */
  REVERSE_LANDSCAPE = 3,
}

/**
 * Describes the enum android.emulation.control.Rotation.SkinRotation.
 */
export const Rotation_SkinRotationSchema: GenEnum<Rotation_SkinRotation> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 26, 0);

/**
 * @generated from message android.emulation.control.PhoneCall
 */
export type PhoneCall = Message<"android.emulation.control.PhoneCall"> & {
  /**
   * @generated from field: android.emulation.control.PhoneCall.Operation operation = 1;
   */
  operation: PhoneCall_Operation;

  /**
   * @generated from field: string number = 2;
   */
  number: string;
};

/**
 * Describes the message android.emulation.control.PhoneCall.
 * Use `create(PhoneCallSchema)` to create a new message.
 */
export const PhoneCallSchema: GenMessage<PhoneCall> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 27);

/**
 * @generated from enum android.emulation.control.PhoneCall.Operation
 */
export enum PhoneCall_Operation {
  /**
   * @generated from enum value: InitCall = 0;
   */
  InitCall = 0,

  /**
   * @generated from enum value: AcceptCall = 1;
   */
  AcceptCall = 1,

  /**
   * @generated from enum value: RejectCallExplicit = 2;
   */
  RejectCallExplicit = 2,

  /**
   * @generated from enum value: RejectCallBusy = 3;
   */
  RejectCallBusy = 3,

  /**
   * @generated from enum value: DisconnectCall = 4;
   */
  DisconnectCall = 4,

  /**
   * @generated from enum value: PlaceCallOnHold = 5;
   */
  PlaceCallOnHold = 5,

  /**
   * @generated from enum value: TakeCallOffHold = 6;
   */
  TakeCallOffHold = 6,
}

/**
 * Describes the enum android.emulation.control.PhoneCall.Operation.
 */
export const PhoneCall_OperationSchema: GenEnum<PhoneCall_Operation> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 27, 0);

/**
 * @generated from message android.emulation.control.PhoneResponse
 */
export type PhoneResponse = Message<"android.emulation.control.PhoneResponse"> & {
  /**
   * @generated from field: android.emulation.control.PhoneResponse.Response response = 1;
   */
  response: PhoneResponse_Response;
};

/**
 * Describes the message android.emulation.control.PhoneResponse.
 * Use `create(PhoneResponseSchema)` to create a new message.
 */
export const PhoneResponseSchema: GenMessage<PhoneResponse> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 28);

/**
 * @generated from enum android.emulation.control.PhoneResponse.Response
 */
export enum PhoneResponse_Response {
  /**
   * @generated from enum value: OK = 0;
   */
  OK = 0,

  /**
   * Enum out of range
   *
   * @generated from enum value: BadOperation = 1;
   */
  BadOperation = 1,

  /**
   * Mal-formed telephone number
   *
   * @generated from enum value: BadNumber = 2;
   */
  BadNumber = 2,

  /**
   * E.g., disconnect when no call is in progress
   *
   * @generated from enum value: InvalidAction = 3;
   */
  InvalidAction = 3,

  /**
   * Internal error
   *
   * @generated from enum value: ActionFailed = 4;
   */
  ActionFailed = 4,

  /**
   * Radio power off
   *
   * @generated from enum value: RadioOff = 5;
   */
  RadioOff = 5,
}

/**
 * Describes the enum android.emulation.control.PhoneResponse.Response.
 */
export const PhoneResponse_ResponseSchema: GenEnum<PhoneResponse_Response> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 28, 0);

/**
 * @generated from message android.emulation.control.Entry
 */
export type Entry = Message<"android.emulation.control.Entry"> & {
  /**
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * @generated from field: string value = 2;
   */
  value: string;
};

/**
 * Describes the message android.emulation.control.Entry.
 * Use `create(EntrySchema)` to create a new message.
 */
export const EntrySchema: GenMessage<Entry> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 29);

/**
 * @generated from message android.emulation.control.EntryList
 */
export type EntryList = Message<"android.emulation.control.EntryList"> & {
  /**
   * @generated from field: repeated android.emulation.control.Entry entry = 1;
   */
  entry: Entry[];
};

/**
 * Describes the message android.emulation.control.EntryList.
 * Use `create(EntryListSchema)` to create a new message.
 */
export const EntryListSchema: GenMessage<EntryList> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 30);

/**
 * @generated from message android.emulation.control.EmulatorStatus
 */
export type EmulatorStatus = Message<"android.emulation.control.EmulatorStatus"> & {
  /**
   * The emulator version string.
   *
   * @generated from field: string version = 1;
   */
  version: string;

  /**
   * The time the emulator has been active in .ms
   *
   * @generated from field: uint64 uptime = 2;
   */
  uptime: bigint;

  /**
   * True if the device has completed booting.
   * For P and later this information will accurate,
   * for older images we rely on adb.
   *
   * @generated from field: bool booted = 3;
   */
  booted: boolean;

  /**
   * The current vm configuration
   *
   * @generated from field: android.emulation.control.VmConfiguration vmConfig = 4;
   */
  vmConfig?: VmConfiguration;

  /**
   * The hardware configuration of the running emulator as
   * key valure pairs.
   *
   * @generated from field: android.emulation.control.EntryList hardwareConfig = 5;
   */
  hardwareConfig?: EntryList;

  /**
   * Some guests will produce a heart beat, that can be used to
   * detect if the guest is active.
   * This is a monotonically increasing number that gets incremented
   * around once a second.
   *
   * @generated from field: uint64 heartbeat = 6;
   */
  heartbeat: bigint;
};

/**
 * Describes the message android.emulation.control.EmulatorStatus.
 * Use `create(EmulatorStatusSchema)` to create a new message.
 */
export const EmulatorStatusSchema: GenMessage<EmulatorStatus> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 31);

/**
 * @generated from message android.emulation.control.AudioFormat
 */
export type AudioFormat = Message<"android.emulation.control.AudioFormat"> & {
  /**
   * Sampling rate to use, defaulting to 44100 if this is not set.
   * Note, that android devices typically will not use a sampling
   * rate higher than 48kHz. See
   * https://developer.android.com/ndk/guides/audio.
   *
   * @generated from field: uint64 samplingRate = 1;
   */
  samplingRate: bigint;

  /**
   * @generated from field: android.emulation.control.AudioFormat.Channels channels = 2;
   */
  channels: AudioFormat_Channels;

  /**
   * @generated from field: android.emulation.control.AudioFormat.SampleFormat format = 3;
   */
  format: AudioFormat_SampleFormat;

  /**
   * [Input Only]
   * The mode used when delivering audio packets.
   *
   * @generated from field: android.emulation.control.AudioFormat.DeliveryMode mode = 4;
   */
  mode: AudioFormat_DeliveryMode;
};

/**
 * Describes the message android.emulation.control.AudioFormat.
 * Use `create(AudioFormatSchema)` to create a new message.
 */
export const AudioFormatSchema: GenMessage<AudioFormat> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 32);

/**
 * @generated from enum android.emulation.control.AudioFormat.SampleFormat
 */
export enum AudioFormat_SampleFormat {
  /**
   * Unsigned 8 bit
   *
   * @generated from enum value: AUD_FMT_U8 = 0;
   */
  AUD_FMT_U8 = 0,

  /**
   * Signed 16 bit (little endian)
   *
   * @generated from enum value: AUD_FMT_S16 = 1;
   */
  AUD_FMT_S16 = 1,
}

/**
 * Describes the enum android.emulation.control.AudioFormat.SampleFormat.
 */
export const AudioFormat_SampleFormatSchema: GenEnum<AudioFormat_SampleFormat> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 32, 0);

/**
 * @generated from enum android.emulation.control.AudioFormat.Channels
 */
export enum AudioFormat_Channels {
  /**
   * @generated from enum value: Mono = 0;
   */
  Mono = 0,

  /**
   * @generated from enum value: Stereo = 1;
   */
  Stereo = 1,
}

/**
 * Describes the enum android.emulation.control.AudioFormat.Channels.
 */
export const AudioFormat_ChannelsSchema: GenEnum<AudioFormat_Channels> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 32, 1);

/**
 * @generated from enum android.emulation.control.AudioFormat.DeliveryMode
 */
export enum AudioFormat_DeliveryMode {
  /**
   * The audio queue will block and wait until the emulator requests
   * packets. The client does not have to throttle and can push packets at
   * will. This can result in the client falling behind.
   *
   * @generated from enum value: MODE_UNSPECIFIED = 0;
   */
  MODE_UNSPECIFIED = 0,

  /**
   * Audio packets will be delivered in real time (when possible). The
   * audio queue will be overwritten with incoming data if data is made
   * available. This means the client needs to control timing properly, or
   * packets will get overwritten.
   *
   *
   *
   * @generated from enum value: MODE_REAL_TIME = 1;
   */
  MODE_REAL_TIME = 1,
}

/**
 * Describes the enum android.emulation.control.AudioFormat.DeliveryMode.
 */
export const AudioFormat_DeliveryModeSchema: GenEnum<AudioFormat_DeliveryMode> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 32, 2);

/**
 * @generated from message android.emulation.control.AudioPacket
 */
export type AudioPacket = Message<"android.emulation.control.AudioPacket"> & {
  /**
   * @generated from field: android.emulation.control.AudioFormat format = 1;
   */
  format?: AudioFormat;

  /**
   * Unix epoch in us when this frame was captured.
   *
   * @generated from field: uint64 timestamp = 2;
   */
  timestamp: bigint;

  /**
   * Contains a sample in the given audio format.
   *
   * @generated from field: bytes audio = 3;
   */
  audio: Uint8Array;
};

/**
 * Describes the message android.emulation.control.AudioPacket.
 * Use `create(AudioPacketSchema)` to create a new message.
 */
export const AudioPacketSchema: GenMessage<AudioPacket> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 33);

/**
 * @generated from message android.emulation.control.SmsMessage
 */
export type SmsMessage = Message<"android.emulation.control.SmsMessage"> & {
  /**
   * The source address where this message came from.
   *
   * The address should be a valid GSM-formatted address as specified by
   * 3GPP 23.040 Sec 9.1.2.5.
   *
   * For example: +3106225412 or (650) 555-1221
   *
   * @generated from field: string srcAddress = 1;
   */
  srcAddress: string;

  /**
   * A utf8 encoded text message that should be delivered.
   *
   * @generated from field: string text = 2;
   */
  text: string;
};

/**
 * Describes the message android.emulation.control.SmsMessage.
 * Use `create(SmsMessageSchema)` to create a new message.
 */
export const SmsMessageSchema: GenMessage<SmsMessage> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 34);

/**
 * A DisplayConfiguration describes a primary or secondary
 * display available to the emulator. The screen aspect ratio
 * cannot be longer (or wider) than 21:9 (or 9:21). Screen sizes
 * larger than 4k will be rejected.
 *
 * Common configurations (w x h) are:
 * - 480p  (480x720)   142 dpi
 * - 720p  (720x1280)  213 dpi
 * - 1080p (1080x1920) 320 dpi
 * - 4K  (2160x3840) 320 dpi
 * - 4K  (2160x3840) 640 dpi (upscaled)
 *
 * The behavior of the virtual display depends on the flags that are provided to
 * this method. By default, virtual displays are created to be private,
 * non-presentation and unsecure.
 *
 * @generated from message android.emulation.control.DisplayConfiguration
 */
export type DisplayConfiguration = Message<"android.emulation.control.DisplayConfiguration"> & {
  /**
   * The width of the display, restricted to:
   * 320 * (dpi / 160) <= width
   *
   * @generated from field: uint32 width = 1;
   */
  width: number;

  /**
   * The heigh of the display, restricted to:
   * * 320 * (dpi / 160) <= height
   *
   * @generated from field: uint32 height = 2;
   */
  height: number;

  /**
   * The pixel density (dpi).
   * See https://developer.android.com/training/multiscreen/screendensities
   * for details. This value should be in the range [120, ..., 640]
   *
   * @generated from field: uint32 dpi = 3;
   */
  dpi: number;

  /**
   * A combination of virtual display flags. These flags can be constructed
   * by combining the DisplayFlags enum described above.
   *
   * The behavior of the virtual display depends on the flags. By default
   * virtual displays are created to be private, non-presentation and
   * unsecure.
   *
   * @generated from field: uint32 flags = 4;
   */
  flags: number;

  /**
   * The id of the display.
   * The primary (default) display has the display ID of 0.
   * A secondary display has a display ID not 0.
   *
   * A display with the id in the range [1, userConfigurable]
   * can be modified. See DisplayConfigurations below for details.
   *
   * The id can be used to get or stream a screenshot.
   *
   * @generated from field: uint32 display = 5;
   */
  display: number;
};

/**
 * Describes the message android.emulation.control.DisplayConfiguration.
 * Use `create(DisplayConfigurationSchema)` to create a new message.
 */
export const DisplayConfigurationSchema: GenMessage<DisplayConfiguration> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 35);

/**
 * These are the set of known android flags and their respective values.
 * you can combine the int values to (de)construct the flags field below.
 *
 * @generated from enum android.emulation.control.DisplayConfiguration.DisplayFlags
 */
export enum DisplayConfiguration_DisplayFlags {
  /**
   * @generated from enum value: DISPLAYFLAGS_UNSPECIFIED = 0;
   */
  DISPLAYFLAGS_UNSPECIFIED = 0,

  /**
   * When this flag is set, the virtual display is public.
   * A public virtual display behaves just like most any other display
   * that is connected to the system such as an external or wireless
   * display. Applications can open windows on the display and the system
   * may mirror the contents of other displays onto it. see:
   * https://developer.android.com/reference/android/hardware/display/DisplayManager#VIRTUAL_DISPLAY_FLAG_PUBLIC
   *
   * @generated from enum value: VIRTUAL_DISPLAY_FLAG_PUBLIC = 1;
   */
  VIRTUAL_DISPLAY_FLAG_PUBLIC = 1,

  /**
   * When this flag is set, the virtual display is registered as a
   * presentation display in the presentation display category.
   * Applications may automatically project their content to presentation
   * displays to provide richer second screen experiences.
   * https://developer.android.com/reference/android/hardware/display/DisplayManager#VIRTUAL_DISPLAY_FLAG_PRESENTATION
   *
   * @generated from enum value: VIRTUAL_DISPLAY_FLAG_PRESENTATION = 2;
   */
  VIRTUAL_DISPLAY_FLAG_PRESENTATION = 2,

  /**
   * When this flag is set, the virtual display is considered secure as
   * defined by the Display#FLAG_SECURE display flag. The caller promises
   * to take reasonable measures, such as over-the-air encryption, to
   * prevent the contents of the display from being intercepted or
   * recorded on a persistent medium.
   * see:
   * https://developer.android.com/reference/android/hardware/display/DisplayManager#VIRTUAL_DISPLAY_FLAG_SECURE
   *
   * @generated from enum value: VIRTUAL_DISPLAY_FLAG_SECURE = 4;
   */
  VIRTUAL_DISPLAY_FLAG_SECURE = 4,

  /**
   * This flag is used in conjunction with VIRTUAL_DISPLAY_FLAG_PUBLIC.
   * Ordinarily public virtual displays will automatically mirror the
   * content of the default display if they have no windows of their own.
   * When this flag is specified, the virtual display will only ever show
   * its own content and will be blanked instead if it has no windows. See
   * https://developer.android.com/reference/android/hardware/display/DisplayManager#VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY
   *
   * @generated from enum value: VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY = 8;
   */
  VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY = 8,

  /**
   * Allows content to be mirrored on private displays when no content is
   * being shown.
   * This flag is mutually exclusive with
   * VIRTUAL_DISPLAY_FLAG_OWN_CONTENT_ONLY. If both flags are specified
   * then the own-content only behavior will be applied.
   * see:
   * https://developer.android.com/reference/android/hardware/display/DisplayManager#VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR)
   *
   * @generated from enum value: VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR = 16;
   */
  VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR = 16,
}

/**
 * Describes the enum android.emulation.control.DisplayConfiguration.DisplayFlags.
 */
export const DisplayConfiguration_DisplayFlagsSchema: GenEnum<DisplayConfiguration_DisplayFlags> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 35, 0);

/**
 * Provides information about all the displays that can be attached
 * to the emulator. The emulator will always have at least one display.
 *
 * The emulator usually has the following display configurations:
 * 0:      The default display.
 * 1 - 3:  User configurable displays. These can be added/removed.
 *         For example the standalone emulator allows you to modify these
 *         in the extended controls.
 * 6 - 11: Fixed external displays. For example Android Auto uses fixed
 *         displays in this range.
 *
 * @generated from message android.emulation.control.DisplayConfigurations
 */
export type DisplayConfigurations = Message<"android.emulation.control.DisplayConfigurations"> & {
  /**
   * @generated from field: repeated android.emulation.control.DisplayConfiguration displays = 1;
   */
  displays: DisplayConfiguration[];

  /**
   * Display configurations with id [1, userConfigurable] are
   * user configurable, that is they can be added, removed or
   * updated.
   *
   * @generated from field: uint32 userConfigurable = 2;
   */
  userConfigurable: number;

  /**
   * The maximum number of attached displays this emulator supports.
   * This is the total number of displays that can be attached to
   * the emulator.
   *
   * Note: A display with an id that is larger than userConfigurable cannot
   * be modified.
   *
   * @generated from field: uint32 maxDisplays = 3;
   */
  maxDisplays: number;
};

/**
 * Describes the message android.emulation.control.DisplayConfigurations.
 * Use `create(DisplayConfigurationsSchema)` to create a new message.
 */
export const DisplayConfigurationsSchema: GenMessage<DisplayConfigurations> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 36);

/**
 * @generated from message android.emulation.control.Notification
 */
export type Notification = Message<"android.emulation.control.Notification"> & {
  /**
   * Deprecated, use the type below to get detailed information
   * regarding the event.
   *
   * @generated from field: android.emulation.control.Notification.EventType event = 1 [deprecated = true];
   * @deprecated
   */
  event: Notification_EventType;

  /**
   * Detailed notification information.
   *
   * @generated from oneof android.emulation.control.Notification.type
   */
  type: {
    /**
     * @generated from field: android.emulation.control.CameraNotification cameraNotification = 2;
     */
    value: CameraNotification;
    case: "cameraNotification";
  } | {
    /**
     * @generated from field: android.emulation.control.DisplayConfigurationsChangedNotification displayConfigurationsChangedNotification = 3;
     */
    value: DisplayConfigurationsChangedNotification;
    case: "displayConfigurationsChangedNotification";
  } | {
    /**
     * @generated from field: android.emulation.control.Posture posture = 4;
     */
    value: Posture;
    case: "posture";
  } | {
    /**
     * @generated from field: android.emulation.control.BootCompletedNotification booted = 5;
     */
    value: BootCompletedNotification;
    case: "booted";
  } | {
    /**
     * @generated from field: android.emulation.control.BrightnessValue brightness = 6;
     */
    value: BrightnessValue;
    case: "brightness";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message android.emulation.control.Notification.
 * Use `create(NotificationSchema)` to create a new message.
 */
export const NotificationSchema: GenMessage<Notification> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 37);

/**
 * @generated from enum android.emulation.control.Notification.EventType
 */
export enum Notification_EventType {
  /**
   * @generated from enum value: VIRTUAL_SCENE_CAMERA_INACTIVE = 0;
   */
  VIRTUAL_SCENE_CAMERA_INACTIVE = 0,

  /**
   * @generated from enum value: VIRTUAL_SCENE_CAMERA_ACTIVE = 1;
   */
  VIRTUAL_SCENE_CAMERA_ACTIVE = 1,

  /**
   * Fired when an update to a display event has been fired through
   * the extended ui. This does not fire events when the display
   * is changed through the console or gRPC endpoint.
   *
   * @generated from enum value: DISPLAY_CONFIGURATIONS_CHANGED_UI = 2;
   */
  DISPLAY_CONFIGURATIONS_CHANGED_UI = 2,
}

/**
 * Describes the enum android.emulation.control.Notification.EventType.
 */
export const Notification_EventTypeSchema: GenEnum<Notification_EventType> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 37, 0);

/**
 * @generated from message android.emulation.control.BootCompletedNotification
 */
export type BootCompletedNotification = Message<"android.emulation.control.BootCompletedNotification"> & {
  /**
   * The time in milliseconds it took for the boot to complete.
   * Note that this value can be 0 when you are loading from a snapshot.
   *
   * @generated from field: int32 time = 1;
   */
  time: number;
};

/**
 * Describes the message android.emulation.control.BootCompletedNotification.
 * Use `create(BootCompletedNotificationSchema)` to create a new message.
 */
export const BootCompletedNotificationSchema: GenMessage<BootCompletedNotification> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 38);

/**
 * Fired when the virtual scene camera is activated or deactivated and also in
 * response to the streamNotification call.
 *
 * @generated from message android.emulation.control.CameraNotification
 */
export type CameraNotification = Message<"android.emulation.control.CameraNotification"> & {
  /**
   * Indicates whether the camera app was activated or deactivated.
   *
   * @generated from field: bool active = 1;
   */
  active: boolean;

  /**
   * The display the camera app is associated with.
   *
   * @generated from field: int32 display = 2;
   */
  display: number;
};

/**
 * Describes the message android.emulation.control.CameraNotification.
 * Use `create(CameraNotificationSchema)` to create a new message.
 */
export const CameraNotificationSchema: GenMessage<CameraNotification> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 39);

/**
 * Fired when an update to a display event has been fired through the extended
 * ui. This does not fire events when the display is changed through the console
 * or the gRPC endpoint.
 *
 * @generated from message android.emulation.control.DisplayConfigurationsChangedNotification
 */
export type DisplayConfigurationsChangedNotification = Message<"android.emulation.control.DisplayConfigurationsChangedNotification"> & {
  /**
   * @generated from field: android.emulation.control.DisplayConfigurations displayConfigurations = 1;
   */
  displayConfigurations?: DisplayConfigurations;
};

/**
 * Describes the message android.emulation.control.DisplayConfigurationsChangedNotification.
 * Use `create(DisplayConfigurationsChangedNotificationSchema)` to create a new message.
 */
export const DisplayConfigurationsChangedNotificationSchema: GenMessage<DisplayConfigurationsChangedNotification> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 40);

/**
 * Rotation angles are relative to the current orientation.
 *
 * @generated from message android.emulation.control.RotationRadian
 */
export type RotationRadian = Message<"android.emulation.control.RotationRadian"> & {
  /**
   * Angle of rotation around the x axis in right-handed direction.
   *
   * @generated from field: float x = 1;
   */
  x: number;

  /**
   * Angle of rotation around the y axis in right-handed direction.
   *
   * @generated from field: float y = 2;
   */
  y: number;

  /**
   * Angle of rotation around the z axis in right-handed direction.
   *
   * @generated from field: float z = 3;
   */
  z: number;
};

/**
 * Describes the message android.emulation.control.RotationRadian.
 * Use `create(RotationRadianSchema)` to create a new message.
 */
export const RotationRadianSchema: GenMessage<RotationRadian> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 41);

/**
 * Velocity is measured in meters per second.
 *
 * @generated from message android.emulation.control.Velocity
 */
export type Velocity = Message<"android.emulation.control.Velocity"> & {
  /**
   * @generated from field: float x = 1;
   */
  x: number;

  /**
   * @generated from field: float y = 2;
   */
  y: number;

  /**
   * @generated from field: float z = 3;
   */
  z: number;
};

/**
 * Describes the message android.emulation.control.Velocity.
 * Use `create(VelocitySchema)` to create a new message.
 */
export const VelocitySchema: GenMessage<Velocity> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 42);

/**
 * Must follow the definition in "external/qemu/android/hw-sensors.h"
 *
 * @generated from message android.emulation.control.Posture
 */
export type Posture = Message<"android.emulation.control.Posture"> & {
  /**
   * @generated from field: android.emulation.control.Posture.PostureValue value = 3;
   */
  value: Posture_PostureValue;
};

/**
 * Describes the message android.emulation.control.Posture.
 * Use `create(PostureSchema)` to create a new message.
 */
export const PostureSchema: GenMessage<Posture> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 43);

/**
 * @generated from enum android.emulation.control.Posture.PostureValue
 */
export enum Posture_PostureValue {
  /**
   * @generated from enum value: POSTURE_UNKNOWN = 0;
   */
  POSTURE_UNKNOWN = 0,

  /**
   * @generated from enum value: POSTURE_CLOSED = 1;
   */
  POSTURE_CLOSED = 1,

  /**
   * @generated from enum value: POSTURE_HALF_OPENED = 2;
   */
  POSTURE_HALF_OPENED = 2,

  /**
   * @generated from enum value: POSTURE_OPENED = 3;
   */
  POSTURE_OPENED = 3,

  /**
   * @generated from enum value: POSTURE_FLIPPED = 4;
   */
  POSTURE_FLIPPED = 4,

  /**
   * @generated from enum value: POSTURE_TENT = 5;
   */
  POSTURE_TENT = 5,

  /**
   * @generated from enum value: POSTURE_MAX = 6;
   */
  POSTURE_MAX = 6,
}

/**
 * Describes the enum android.emulation.control.Posture.PostureValue.
 */
export const Posture_PostureValueSchema: GenEnum<Posture_PostureValue> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 43, 0);

/**
 * @generated from message android.emulation.control.PhoneNumber
 */
export type PhoneNumber = Message<"android.emulation.control.PhoneNumber"> & {
  /**
   *
   * The phone number should be a valid GSM-formatted number as specified by
   * 3GPP 23.040 Sec 9.1.2.5.
   *
   * For example: +3106225412 or (650) 555-1221
   *
   * @generated from field: string number = 1;
   */
  number: string;
};

/**
 * Describes the message android.emulation.control.PhoneNumber.
 * Use `create(PhoneNumberSchema)` to create a new message.
 */
export const PhoneNumberSchema: GenMessage<PhoneNumber> = /*@__PURE__*/
  messageDesc(file_emulator_controller, 44);

/**
 * in line with android/emulation/resizable_display_config.h
 *
 * @generated from enum android.emulation.control.DisplayModeValue
 */
export enum DisplayModeValue {
  /**
   * @generated from enum value: PHONE = 0;
   */
  PHONE = 0,

  /**
   * @generated from enum value: FOLDABLE = 1;
   */
  FOLDABLE = 1,

  /**
   * @generated from enum value: TABLET = 2;
   */
  TABLET = 2,

  /**
   * @generated from enum value: DESKTOP = 3;
   */
  DESKTOP = 3,
}

/**
 * Describes the enum android.emulation.control.DisplayModeValue.
 */
export const DisplayModeValueSchema: GenEnum<DisplayModeValue> = /*@__PURE__*/
  enumDesc(file_emulator_controller, 0);

/**
 * An EmulatorController service lets you control the emulator.
 * Note that this is currently an experimental feature, and that the
 * service definition might change without notice. Use at your own risk!
 *
 * We use the following rough conventions:
 *
 * streamXXX --> streams values XXX (usually for emulator lifetime). Values
 *               are updated as soon as they become available.
 * getXXX    --> gets a single value XXX
 * setXXX    --> sets a single value XXX, does not returning state, these
 *               usually have an observable lasting side effect.
 * sendXXX   --> send a single event XXX, possibly returning state information.
 *               android usually responds to these events.
 *
 * @generated from service android.emulation.control.EmulatorController
 */
export const EmulatorController: GenService<{
  /**
   * set/get/stream the sensor data
   *
   * @generated from rpc android.emulation.control.EmulatorController.streamSensor
   */
  streamSensor: {
    methodKind: "server_streaming";
    input: typeof SensorValueSchema;
    output: typeof SensorValueSchema;
  },
  /**
   * @generated from rpc android.emulation.control.EmulatorController.getSensor
   */
  getSensor: {
    methodKind: "unary";
    input: typeof SensorValueSchema;
    output: typeof SensorValueSchema;
  },
  /**
   * @generated from rpc android.emulation.control.EmulatorController.setSensor
   */
  setSensor: {
    methodKind: "unary";
    input: typeof SensorValueSchema;
    output: typeof EmptySchema;
  },
  /**
   * set/get/stream the physical model, this is likely the one you are
   * looking for when you wish to modify the device state.
   *
   * @generated from rpc android.emulation.control.EmulatorController.setPhysicalModel
   */
  setPhysicalModel: {
    methodKind: "unary";
    input: typeof PhysicalModelValueSchema;
    output: typeof EmptySchema;
  },
  /**
   * @generated from rpc android.emulation.control.EmulatorController.getPhysicalModel
   */
  getPhysicalModel: {
    methodKind: "unary";
    input: typeof PhysicalModelValueSchema;
    output: typeof PhysicalModelValueSchema;
  },
  /**
   * @generated from rpc android.emulation.control.EmulatorController.streamPhysicalModel
   */
  streamPhysicalModel: {
    methodKind: "server_streaming";
    input: typeof PhysicalModelValueSchema;
    output: typeof PhysicalModelValueSchema;
  },
  /**
   * Atomically set/get the current primary clipboard data.
   * Note that a call to setClipboard will result in an immediate
   * event for those who made a call to streamClipboard and are
   * on a different channel than the one used to set the clipboard.
   *
   * @generated from rpc android.emulation.control.EmulatorController.setClipboard
   */
  setClipboard: {
    methodKind: "unary";
    input: typeof ClipDataSchema;
    output: typeof EmptySchema;
  },
  /**
   * @generated from rpc android.emulation.control.EmulatorController.getClipboard
   */
  getClipboard: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof ClipDataSchema;
  },
  /**
   * Streams the current data on the clipboard. This will immediately produce
   * a result with the current state of the clipboard after which the stream
   * will block and wait until a new clip event is available from the guest.
   * Calling the setClipboard method above will not result in generating a
   * clip event. It is possible to lose clipboard events if the clipboard
   * updates very rapidly.
   *
   * @generated from rpc android.emulation.control.EmulatorController.streamClipboard
   */
  streamClipboard: {
    methodKind: "server_streaming";
    input: typeof EmptySchema;
    output: typeof ClipDataSchema;
  },
  /**
   * Set/get the battery to the given state.
   *
   * @generated from rpc android.emulation.control.EmulatorController.setBattery
   */
  setBattery: {
    methodKind: "unary";
    input: typeof BatteryStateSchema;
    output: typeof EmptySchema;
  },
  /**
   * @generated from rpc android.emulation.control.EmulatorController.getBattery
   */
  getBattery: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof BatteryStateSchema;
  },
  /**
   * Set the state of the gps.
   * Note: Setting the gps position will not be reflected in the user
   * interface. Keep in mind that android usually only samples the gps at 1
   * hz.
   *
   * @generated from rpc android.emulation.control.EmulatorController.setGps
   */
  setGps: {
    methodKind: "unary";
    input: typeof GpsStateSchema;
    output: typeof EmptySchema;
  },
  /**
   * Gets the latest gps state as delivered by the setGps call, or location ui
   * if active.
   *
   * Note: this is not necessarily the actual gps coordinate visible at the
   * time, due to gps sample frequency (usually 1hz).
   *
   * @generated from rpc android.emulation.control.EmulatorController.getGps
   */
  getGps: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof GpsStateSchema;
  },
  /**
   * Simulate a touch event on the finger print sensor.
   *
   * @generated from rpc android.emulation.control.EmulatorController.sendFingerprint
   */
  sendFingerprint: {
    methodKind: "unary";
    input: typeof FingerprintSchema;
    output: typeof EmptySchema;
  },
  /**
   * Send a keyboard event. Translating the event.
   *
   * @generated from rpc android.emulation.control.EmulatorController.sendKey
   */
  sendKey: {
    methodKind: "unary";
    input: typeof KeyboardEventSchema;
    output: typeof EmptySchema;
  },
  /**
   * Send touch/mouse events. Note that mouse events can be simulated
   * by touch events.
   *
   * @generated from rpc android.emulation.control.EmulatorController.sendTouch
   */
  sendTouch: {
    methodKind: "unary";
    input: typeof TouchEventSchema;
    output: typeof EmptySchema;
  },
  /**
   * @generated from rpc android.emulation.control.EmulatorController.sendMouse
   */
  sendMouse: {
    methodKind: "unary";
    input: typeof MouseEventSchema;
    output: typeof EmptySchema;
  },
  /**
   * @generated from rpc android.emulation.control.EmulatorController.injectWheel
   */
  injectWheel: {
    methodKind: "client_streaming";
    input: typeof WheelEventSchema;
    output: typeof EmptySchema;
  },
  /**
   * Stream a series of input events to the emulator, the events will
   * arrive in order.
   *
   * @generated from rpc android.emulation.control.EmulatorController.streamInputEvent
   */
  streamInputEvent: {
    methodKind: "client_streaming";
    input: typeof InputEventSchema;
    output: typeof EmptySchema;
  },
  /**
   * Make a phone call.
   *
   * @generated from rpc android.emulation.control.EmulatorController.sendPhone
   */
  sendPhone: {
    methodKind: "unary";
    input: typeof PhoneCallSchema;
    output: typeof PhoneResponseSchema;
  },
  /**
   * Sends an sms message to the emulator.
   *
   * @generated from rpc android.emulation.control.EmulatorController.sendSms
   */
  sendSms: {
    methodKind: "unary";
    input: typeof SmsMessageSchema;
    output: typeof PhoneResponseSchema;
  },
  /**
   * Sends an sms message to the emulator.
   *
   * @generated from rpc android.emulation.control.EmulatorController.setPhoneNumber
   */
  setPhoneNumber: {
    methodKind: "unary";
    input: typeof PhoneNumberSchema;
    output: typeof PhoneResponseSchema;
  },
  /**
   * Retrieve the status of the emulator. This will contain general
   * hardware information, and whether the device has booted or not.
   *
   * @generated from rpc android.emulation.control.EmulatorController.getStatus
   */
  getStatus: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof EmulatorStatusSchema;
  },
  /**
   * Gets an individual screenshot in the desired format.
   *
   * The image will be scaled to the desired ImageFormat, while maintaining
   * the aspect ratio. The returned image will never exceed resolution of the
   * device display. Not setting the width or height (i.e. they are 0) will
   * result in using the display width and height.
   *
   * The resulting image will be properly oriented and can be displayed
   * directly without post processing. For example, if the device has a
   * 1080x1920 screen and is in landscape mode and called with no width or
   * height parameter, it will return a 1920x1080 image.
   *
   * The dimensions of the returned image will never exceed the corresponding
   * display dimensions. For example, this method will return a 1920x1080
   * screenshot, if the display resolution is 1080x1920 and a screenshot of
   * 2048x2048 is requested when the device is in landscape mode.
   *
   * This method will return an empty image if the display is not visible.
   *
   * @generated from rpc android.emulation.control.EmulatorController.getScreenshot
   */
  getScreenshot: {
    methodKind: "unary";
    input: typeof ImageFormatSchema;
    output: typeof ImageSchema;
  },
  /**
   * Streams a series of screenshots in the desired format.
   *
   * A new frame will be delivered whenever the device produces a new frame.
   * Beware that this can produce a significant amount of data and that
   * certain translations can be very costly. For example, streaming a series
   * of png images is very cpu intensive.
   *
   * Images are produced according to the getScreenshot API described above.
   *
   * If the display is inactive, or becomes inactive, an empty image will be
   * delivered. Images will be delived again if the display becomes active and
   * new frames are produced.
   *
   * @generated from rpc android.emulation.control.EmulatorController.streamScreenshot
   */
  streamScreenshot: {
    methodKind: "server_streaming";
    input: typeof ImageFormatSchema;
    output: typeof ImageSchema;
  },
  /**
   * Streams a series of audio packets in the desired format.
   * A new frame will be delivered whenever the emulated device
   * produces a new audio frame. You can expect packets to be
   * delivered in intervals of 20-30ms.
   *
   * Be aware that this can block when the emulator does not
   * produce any audio whatsoever!
   *
   * @generated from rpc android.emulation.control.EmulatorController.streamAudio
   */
  streamAudio: {
    methodKind: "server_streaming";
    input: typeof AudioFormatSchema;
    output: typeof AudioPacketSchema;
  },
  /**
   * Injects a series of audio packets to the android microphone.
   * A new frame will be delivered whenever the emulated device
   * requests a new audio frame. Audio is usually delivered at a rate
   * that the emulator is requesting frames. Audio will be stored in a
   * temporary buffer that can hold 300ms of audio.
   *
   * Notes:
   *  - Only the first audio format packet that is delivered will be
   * honored. There is no need to send the audio format multiple times.
   *  - Real time audio currently immediately overrides the buffer. This
   * means you must provide a constant rate of audio packets. The real
   * time mode is experimental. Timestamps of audio packets might be
   * used in the future to improve synchronization.
   *
   * -  INVALID_ARGUMENT (code 3) The sampling rate was too high/low
   * -  INVALID_ARGUMENT (code 3) The audio packet was too large to handle.
   * -  FAILED_PRECONDITION (code 9) If there was a microphone registered
   * already.
   *
   * @generated from rpc android.emulation.control.EmulatorController.injectAudio
   */
  injectAudio: {
    methodKind: "client_streaming";
    input: typeof AudioPacketSchema;
    output: typeof EmptySchema;
  },
  /**
   * Deprecated, please use the streamLogcat method instead.
   *
   * @generated from rpc android.emulation.control.EmulatorController.getLogcat
   * @deprecated
   */
  getLogcat: {
    methodKind: "unary";
    input: typeof LogMessageSchema;
    output: typeof LogMessageSchema;
  },
  /**
   * Streams the logcat output from the emulator.
   * Note that parsed logcat messages are only available after L (Api >23)
   *
   * @generated from rpc android.emulation.control.EmulatorController.streamLogcat
   */
  streamLogcat: {
    methodKind: "server_streaming";
    input: typeof LogMessageSchema;
    output: typeof LogMessageSchema;
  },
  /**
   * Transition the virtual machine to the desired state. Note that
   * some states are only observable. For example you cannot transition
   * to the error state.
   *
   * @generated from rpc android.emulation.control.EmulatorController.setVmState
   */
  setVmState: {
    methodKind: "unary";
    input: typeof VmRunStateSchema;
    output: typeof EmptySchema;
  },
  /**
   * Gets the state of the virtual machine.
   *
   * @generated from rpc android.emulation.control.EmulatorController.getVmState
   */
  getVmState: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof VmRunStateSchema;
  },
  /**
   * Atomically changes the current multi-display configuration.
   * After this call the given display configurations will be activated. You
   * can only update secondary displays. Displays with id 0 will be ignored.
   *
   * This call can result in the removal or addition of secondary displays,
   * the final display state can be observed by the returned configuration.
   *
   * The following gRPC error codes can be returned:
   * -  FAILED_PRECONDITION (code 9) if the AVD does not support a
   * configurable
   *    secondary display.
   * -  INVALID_ARGUMENT (code 3) if:
   *     - The same display id is defined multiple times.
   *     - The display configurations are outside valid ranges.
   *       See DisplayConfiguration for details on valid ranges.
   * -  INTERNAL (code 13) if there was an internal emulator failure.
   *
   * @generated from rpc android.emulation.control.EmulatorController.setDisplayConfigurations
   */
  setDisplayConfigurations: {
    methodKind: "unary";
    input: typeof DisplayConfigurationsSchema;
    output: typeof DisplayConfigurationsSchema;
  },
  /**
   * Returns all currently valid logical displays.
   *
   * The gRPC error code FAILED_PRECONDITION (code 9) is returned if the AVD
   * does not support a configurable secondary display.
   *
   * @generated from rpc android.emulation.control.EmulatorController.getDisplayConfigurations
   */
  getDisplayConfigurations: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof DisplayConfigurationsSchema;
  },
  /**
   * Notifies client of the following changes:
   *
   * - Virtual scene camera status change.
   * - Display configuration changes from extended ui. This will only be fired
   *   if the user makes modifications the extended displays through the
   *   extended control tab.
   *
   * Note that this method will send the initial virtual scene state
   * immediately.
   *
   * @generated from rpc android.emulation.control.EmulatorController.streamNotification
   */
  streamNotification: {
    methodKind: "server_streaming";
    input: typeof EmptySchema;
    output: typeof NotificationSchema;
  },
  /**
   * Rotation angles are relative to the camera's current orientation.
   * The coordinate system is right-handed and is defined as follows:
   *   x axis is pointing right
   *   y axis is pointing up
   *   z axis is pointing towards the viewer
   * The z component of rotation is not used when calling this method.
   *
   * @generated from rpc android.emulation.control.EmulatorController.rotateVirtualSceneCamera
   */
  rotateVirtualSceneCamera: {
    methodKind: "unary";
    input: typeof RotationRadianSchema;
    output: typeof EmptySchema;
  },
  /**
   * Velocity is absolute and is measured in meters per second.
   * The coordinate system is right-handed and is defined as follows:
   *   x axis is pointing right
   *   y axis is pointing up
   *   z axis is pointing towards the viewer
   *
   * @generated from rpc android.emulation.control.EmulatorController.setVirtualSceneCameraVelocity
   */
  setVirtualSceneCameraVelocity: {
    methodKind: "unary";
    input: typeof VelocitySchema;
    output: typeof EmptySchema;
  },
  /**
   * Set foldable posture
   *
   * @generated from rpc android.emulation.control.EmulatorController.setPosture
   */
  setPosture: {
    methodKind: "unary";
    input: typeof PostureSchema;
    output: typeof EmptySchema;
  },
  /**
   * Get the backlight brightness.
   * The following gRPC error codes can be returned:
   * -  FAILED_PRECONDITION (code 9) if the AVD does not support hw-control.
   *
   * @generated from rpc android.emulation.control.EmulatorController.getBrightness
   */
  getBrightness: {
    methodKind: "unary";
    input: typeof BrightnessValueSchema;
    output: typeof BrightnessValueSchema;
  },
  /**
   * Set the backlight brightness.
   * The following gRPC error codes can be returned:
   * -  FAILED_PRECONDITION (code 9) if the AVD does not support hw-control.
   * -  INVALID_ARGUMENT (code 3) The brightness exceeds the valid range.
   *
   * @generated from rpc android.emulation.control.EmulatorController.setBrightness
   */
  setBrightness: {
    methodKind: "unary";
    input: typeof BrightnessValueSchema;
    output: typeof EmptySchema;
  },
  /**
   * Returns the current mode of the primary display of a resizable AVD.
   * The following gRPC error codes can be returned:
   * -  FAILED_PRECONDITION (code 9) if the AVD is not resizable.
   *
   * @generated from rpc android.emulation.control.EmulatorController.getDisplayMode
   */
  getDisplayMode: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof DisplayModeSchema;
  },
  /**
   * Sets the size of the primary display of a resizable AVD. Fails if the AVD
   * is not resizable. The following gRPC error codes can be returned:
   * -  FAILED_PRECONDITION (code 9) if the AVD is not resizable.
   *
   * @generated from rpc android.emulation.control.EmulatorController.setDisplayMode
   */
  setDisplayMode: {
    methodKind: "unary";
    input: typeof DisplayModeSchema;
    output: typeof EmptySchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_emulator_controller, 0);

