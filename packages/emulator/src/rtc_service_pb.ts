// https://android.googlesource.com/platform/external/qemu/+/emu-master-dev/android/android-webrtc/android-webrtc/rtc_service.proto

// Copyright (C) 2018 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Note that if you add/remove methods in this file you must update
// the metrics sql as well by running ./android/scripts/gen-grpc-sql.py
//
// Please group deleted methods in a block including the date (MM/DD/YY)
// it was removed. This enables us to easily keep metrics around after removal
//
// List of deleted methods
// rpc iWasDeleted (03/12/12)
// ...

// @generated by protoc-gen-es v2.2.2 with parameter "target=ts,ts_nocheck=false"
// @generated from file rtc_service.proto (package android.emulation.control, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv1";
import type { EmptySchema } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_empty } from "@bufbuild/protobuf/wkt";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file rtc_service.proto.
 */
export const file_rtc_service: GenFile = /*@__PURE__*/
  fileDesc("ChFydGNfc2VydmljZS5wcm90bxIZYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbCIVCgVSdGNJZBIMCgRndWlkGAEgASgJIkgKB0pzZXBNc2cSLAoCaWQYASABKAsyIC5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLlJ0Y0lkEg8KB21lc3NhZ2UYAiABKAky5QIKA1J0YxJOChByZXF1ZXN0UnRjU3RyZWFtEhYuZ29vZ2xlLnByb3RvYnVmLkVtcHR5GiAuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5SdGNJZCIAEk8KD3NlbmRKc2VwTWVzc2FnZRIiLmFuZHJvaWQuZW11bGF0aW9uLmNvbnRyb2wuSnNlcE1zZxoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eSIAEl8KE3JlY2VpdmVKc2VwTWVzc2FnZXMSIC5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLlJ0Y0lkGiIuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5Kc2VwTXNnIgAwARJcChJyZWNlaXZlSnNlcE1lc3NhZ2USIC5hbmRyb2lkLmVtdWxhdGlvbi5jb250cm9sLlJ0Y0lkGiIuYW5kcm9pZC5lbXVsYXRpb24uY29udHJvbC5Kc2VwTXNnIgBCJgocY29tLmFuZHJvaWQuZW11bGF0b3IuY29udHJvbFABogIDQUVDYgZwcm90bzM", [file_google_protobuf_empty]);

/**
 * @generated from message android.emulation.control.RtcId
 */
export type RtcId = Message<"android.emulation.control.RtcId"> & {
  /**
   * The unique identifier of this connection. You will have to use the
   * same identifier when sending/receiving messages. The server will
   * generate a guid when receiving the start message.
   *
   * @generated from field: string guid = 1;
   */
  guid: string;
};

/**
 * Describes the message android.emulation.control.RtcId.
 * Use `create(RtcIdSchema)` to create a new message.
 */
export const RtcIdSchema: GenMessage<RtcId> = /*@__PURE__*/
  messageDesc(file_rtc_service, 0);

/**
 * @generated from message android.emulation.control.JsepMsg
 */
export type JsepMsg = Message<"android.emulation.control.JsepMsg"> & {
  /**
   * The unique identifier of this connection. You will have to use the
   * same identifier when sending/receiving messages. The server will
   * generate a guid when receiving the start message.
   *
   * @generated from field: android.emulation.control.RtcId id = 1;
   */
  id?: RtcId;

  /**
   * The JSON payload. This usually can be directly handled by the
   * Javascript library.
   *
   * The dictionary can contain the following properties
   *
   * - bye:
   *        You can hang up now. No new message expected for you.
   *        The server has stopped the RTC stream.
   *
   * - start:
   *        An RTCConfiguration dictionary providing options to
   *        configure the new connection. This can include the
   *        turn configuration the serve is using. This dictionary can be
   *        passed in directly to the
   *        [RTCPeerConnection](https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection)
   *        object.
   *
   * - candidate:
   *        The WebRTC API's RTCIceCandidateInit dictionary, which
   *        contains the information needed to fundamentally describe an
   *        RTCIceCandidate. See
   *        [RTCIceCandidate](https://developer.mozilla.org/en-US/docs/Web/API/RTCIceCandidate)
   *        and [Session
   *        Lifetime](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Session_lifetime)
   *        for more details.
   *
   * - sdp:
   *        RTCSessionDescriptionInit dictionary containing the values
   *        to that can be assigned to a
   *        [RTCSessionDescription](https://developer.mozilla.org/en-US/docs/Web/API/RTCSessionDescription)
   *
   * @generated from field: string message = 2;
   */
  message: string;
};

/**
 * Describes the message android.emulation.control.JsepMsg.
 * Use `create(JsepMsgSchema)` to create a new message.
 */
export const JsepMsgSchema: GenMessage<JsepMsg> = /*@__PURE__*/
  messageDesc(file_rtc_service, 1);

/**
 * An RTC service lets you interact with the emulator through WebRTC
 * Note that this is currently an experimental feature, and that the
 * service definition might change without notice. Use at your own risk!
 *
 * The following endpoints are needed to establish the webrtc protocol
 * Due to limitiations in Javascript we cannot make use of bidirectional
 * endpoints See this [blog](https://grpc.io/blog/state-of-grpc-web) for
 * details.
 *
 * @generated from service android.emulation.control.Rtc
 */
export const Rtc: GenService<{
  /**
   * This function will generate a new identifier that the client
   * should use for further interaction. It will initiate the
   * JSEP protocol on the server side.
   *
   * @generated from rpc android.emulation.control.Rtc.requestRtcStream
   */
  requestRtcStream: {
    methodKind: "unary";
    input: typeof EmptySchema;
    output: typeof RtcIdSchema;
  },
  /**
   * Sends the given JsepMsg to the server. The RtcId in the
   * message should point to an active stream negotiation in
   * progress, otherwise the message will be ignored.
   *
   * @generated from rpc android.emulation.control.Rtc.sendJsepMessage
   */
  sendJsepMessage: {
    methodKind: "unary";
    input: typeof JsepMsgSchema;
    output: typeof EmptySchema;
  },
  /**
   * Reads an available jsep messages for the given client id,
   * blocking until one becomes available. Do not use the polling version
   * above if you opt for this one.
   *
   * The ice candidates for example will trickle in on this callback,
   * as will the SDP negotation.
   *
   * @generated from rpc android.emulation.control.Rtc.receiveJsepMessages
   */
  receiveJsepMessages: {
    methodKind: "server_streaming";
    input: typeof RtcIdSchema;
    output: typeof JsepMsgSchema;
  },
  /**
   * [DEPRECATED] This is only here as the go grpc webproxy used
   * by fuchsia does not support server side streaming. This method
   * will be removed in the future and should not be relied upon.
   *
   * Reads an available jsep messages for the given client id,
   * blocking until one becomes available. Do not use the polling version
   * above if you opt for this one.
   *
   * The ice candidates for example will trickle in on this callback,
   * as will the SDP negotation.
   *
   * @generated from rpc android.emulation.control.Rtc.receiveJsepMessage
   */
  receiveJsepMessage: {
    methodKind: "unary";
    input: typeof RtcIdSchema;
    output: typeof JsepMsgSchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_rtc_service, 0);

